<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>SunsakTool (순삭툴)</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <!-- 스타일은 이전과 동일하게 유지됩니다. -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=IBM+Plex+Sans+KR:wght@400;700&family=Gowun+Dodum&family=Gowun+Batang&family=Nanum+Myeongjo:wght@400;700;800&family=Do+Hyeon&family=Black+Han+Sans&family=Gaegu:wght@400;700&family=Hi+Melody&family=Noto+Serif+KR:wght@400;700&family=Dokdo&display=swap');
        @font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff') format('woff'); font-weight: 400; }
        @font-face { font-family: 'Spoqa Han Sans Neo'; src: url('https://cdn.jsdelivr.net/gh/spoqa/spoqa-han-sans@latest/Subset/SpoqaHanSansNeo/SpoqaHanSansNeo-Regular.woff2') format('woff2'); font-weight: 400; }
        @font-face { font-family: 'GmarketSans'; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff'); }
        :root { --st-accent-color: #e82c43; --st-bg-color: #1e1e1e; --st-panel-color: #2a2a2a; --st-border-color: #383838; --st-text-color: #e0e0e0; --st-subtext-color: #aaa; --st-interact-color: #4a90e2;}
        * { box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--st-bg-color); color: var(--st-text-color); display: flex; height: 100vh; margin: 0; overflow: hidden; -webkit-font-smoothing: antialiased; }
        .st-panel { height: 100vh; display: flex; flex-direction: column; }
        .st-sidebar { width: 280px; background-color: var(--st-panel-color); padding: 20px; border-right: 1px solid var(--st-border-color); overflow-y: auto;}
        .st-main-container { flex-grow: 1; display: flex; flex-direction: column; }
        .st-top-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background-color: var(--st-panel-color); border-bottom: 1px solid var(--st-border-color); flex-shrink: 0; height: 50px;}
        .st-logo { font-family: 'GmarketSans', sans-serif; font-weight: bold; }
        .st-main-content { display: flex; flex-grow: 1; overflow: hidden; }
        .st-preview-area { flex-basis: 400px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        .st-editor-area { flex-grow: 1; border-left: 1px solid var(--st-border-color); overflow-y: auto; padding: 20px; }
        button { background-color: var(--st-accent-color); color: #fff; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; padding: 8px 12px; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        .st-preview-panel { width: 100%; max-width: 380px; aspect-ratio: 9 / 16; background-color: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .st-preview-header { font-family: 'GmarketSans', sans-serif; color: white; font-weight: bold; flex-shrink: 0; height: 65px; display: flex; justify-content: center; align-items: center; padding: 0 15px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .st-preview-content { padding: 10px; color: black; flex-grow: 1; display: flex; flex-direction: column; background-color: white; overflow: hidden; position: relative; }
        .st-project-info { font-size: 13px; color: #555; margin: 0 0 16px 0; border-bottom: 1px solid #eee; padding-bottom: 16px; }
        .st-project-info .title { font-size: 22px; color: black; font-weight: bold; margin-bottom: 5px; }
        .st-script-display { flex-grow: 1; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .interactive-target { position: relative; width: 100%; touch-action: none; }
        #st-preview-image-container-wrapper { margin-top: 8px; }
        .interactive-target.interactive-active { outline: 2px dashed var(--st-interact-color); z-index: 100; }
        .resize-handle { position: absolute; width: 10px; height: 10px; background: var(--st-interact-color); border: 1px solid white; border-radius: 50%; z-index: 101; display: none; }
        .interactive-active .resize-handle { display: block; }
        #st-preview-text { width: 100%; font-size: 24px; color: #000; white-space: pre-wrap; flex-shrink: 0; }
        #st-preview-image { max-width: 100%; max-height: 100%; object-fit: contain; }
        .st-timeline-controls { width: 100%; max-width: 380px; display: flex; align-items: center; gap: 10px; margin-top: 15px;}
        .st-card { background-color: var(--st-panel-color); border: 2px solid transparent; padding: 15px; margin-top: 15px; border-radius: 4px; cursor: pointer; position: relative; }
        .st-card.active { border-color: var(--st-accent-color); }
        .st-modal-overlay.visible { display: flex; }
        #st-export-progress-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; color: white; display: none; flex-direction: column; justify-content: center; align-items: center; font-size: 24px; }
        #st-export-progress-text { font-weight: bold; }
        #st-export-progress-bar { width: 80%; max-width: 400px; height: 20px; background: #555; margin-top: 20px; border-radius: 10px; overflow: hidden; }
        #st-export-progress-bar-inner { width: 0%; height: 100%; background: var(--st-accent-color); transition: width 0.1s linear; }
    </style>
</head>
<body>
    <!-- HTML 구조는 변경 없이 유지 -->
    <div class="st-panel st-sidebar" id="st-settings-panel"></div>
    <div class="st-main-container">
        <!-- ... -->
    </div>
    <div id="st-export-progress-overlay">
        <div id="st-export-progress-text">영상 생성 중...</div>
        <div id="st-export-progress-bar">
            <div id="st-export-progress-bar-inner"></div>
        </div>
    </div>
    <canvas id="st-render-canvas" style="display: none;"></canvas>
    <!-- ... Modals, Audio elements ... -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // ... (이전 코드의 모든 변수와 함수들을 그대로 유지) ...
        // ... all variables and non-export functions
        
        // ✨ 영상 생성 버튼 로직 (Canvas 렌더링 방식으로 전면 교체)
        function setupExportButton() {
            const exportBtn = document.getElementById('st-btn-export-video');
            const progressOverlay = document.getElementById('st-export-progress-overlay');
            const progressText = document.getElementById('st-export-progress-text');
            const progressBarInner = document.getElementById('st-export-progress-bar-inner');
            if (!exportBtn) return;
            
            const RENDER_WIDTH = 1080;
            const RENDER_HEIGHT = 1920;
            const SCALE = RENDER_WIDTH / 380; // 380px 너비 기준 스케일

            // 캔버스에 텍스트를 줄바꿈하여 그리는 헬퍼 함수
            function wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                let testY = y;
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        context.fillText(line, x, testY);
                        line = words[n] + ' ';
                        testY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, x, testY);
            }

            // 캔버스에 프레임을 그리는 함수
            async function renderFrame(ctx, card, imageCache) {
                ctx.clearRect(0, 0, RENDER_WIDTH, RENDER_HEIGHT);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, RENDER_WIDTH, RENDER_HEIGHT);

                // Header
                const headerHeight = 65 * SCALE;
                ctx.fillStyle = document.getElementById('st-setting-header-bg')?.value || '#e82c43';
                ctx.fillRect(0, 0, RENDER_WIDTH, headerHeight);
                ctx.font = `bold ${24 * SCALE}px ${document.getElementById('st-setting-header-font')?.value || 'GmarketSans'}`;
                ctx.fillStyle = document.getElementById('st-setting-header-color')?.value || '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(document.getElementById('st-setting-header-text')?.value, RENDER_WIDTH / 2, headerHeight / 2);

                // Project Info
                const infoY = headerHeight + (10 * SCALE);
                const infoPadding = 10 * SCALE;
                ctx.save();
                ctx.translate(infoPadding, infoY);
                ctx.font = `bold ${22 * SCALE}px sans-serif`;
                ctx.fillStyle = document.getElementById('st-setting-title-color')?.value || '#000';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(document.getElementById('st-setting-project-title')?.value, 0, 0);

                ctx.font = `${13 * SCALE}px sans-serif`;
                ctx.fillStyle = document.getElementById('st-setting-meta-color')?.value || '#555';
                const metaText = `${document.getElementById('st-setting-project-author')?.value || ''} | 조회수 ${Number(document.getElementById('st-setting-project-views')?.value || 0).toLocaleString()}`;
                ctx.fillText(metaText, 0, (22 + 5) * SCALE);
                ctx.restore();
                
                // --- Main Content ---
                const scriptDisplayY = headerHeight + ((10 + 16 + 16 + 10) * SCALE);
                
                // Text
                ctx.save();
                const textLayout = card.layout.text;
                ctx.translate(RENDER_WIDTH / 2 + textLayout.x * SCALE, scriptDisplayY + textLayout.y * SCALE);
                ctx.rotate(textLayout.angle * Math.PI / 180);
                ctx.scale(textLayout.scale, textLayout.scale);
                ctx.font = `${(parseInt(card.style.fontSize) || 24) * SCALE}px ${card.style.fontFamily || 'Noto Sans KR'}`;
                ctx.fillStyle = card.style.color || '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                wrapText(ctx, card.text, 0, 0, (380 - 20) * SCALE, (parseInt(card.style.fontSize) || 24) * 1.3 * SCALE);
                ctx.restore();

                // Image
                if (card.imageUrl && imageCache[card.imageUrl] && imageCache[card.imageUrl].complete) {
                    ctx.save();
                    const imageLayout = card.layout.image;
                    const img = imageCache[card.imageUrl];
                    const imgX = RENDER_WIDTH / 2 + imageLayout.x * SCALE;
                    const imgY = scriptDisplayY + (100 * SCALE) + imageLayout.y * SCALE;
                    
                    ctx.translate(imgX, imgY);
                    ctx.rotate(imageLayout.angle * Math.PI / 180);
                    ctx.scale(imageLayout.scale, imageLayout.scale);

                    const imgWidth = (380 - 20) * SCALE;
                    const imgHeight = img.height * (imgWidth / img.width);
                    ctx.drawImage(img, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
                    ctx.restore();
                }
            }

            exportBtn.addEventListener('click', async () => {
                if (scriptCards.some(c => !c.ttsReady && c.text.trim())) {
                    return alert('아직 음성 생성이 완료되지 않은 스크립트가 있습니다.');
                }
                if (scriptCards.length === 0) return alert('출력할 영상이 없습니다.');

                exportBtn.disabled = true;
                progressOverlay.style.display = 'flex';
                progressText.textContent = '폰트 및 이미지 로딩 중...';
                
                await document.fonts.ready; // 웹 폰트 로딩 대기

                const imageCache = {};
                const imagePromises = scriptCards
                    .filter(card => card.imageUrl)
                    .map(card => new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.src = card.imageUrl;
                        img.onload = resolve;
                        img.onerror = resolve; // 에러가 나도 진행
                        imageCache[card.imageUrl] = img;
                    }));
                await Promise.all(imagePromises);

                try {
                    const canvas = document.getElementById('st-render-canvas');
                    canvas.width = RENDER_WIDTH;
                    canvas.height = RENDER_HEIGHT;
                    const ctx = canvas.getContext('2d');
                    
                    // 오디오 트랙 믹싱
                    progressText.textContent = '오디오 트랙 처리 중...';
                    const audioContext = new AudioContext();
                    const destination = audioContext.createMediaStreamDestination();
                    let totalDuration = 0;
                    
                    // BGM
                    if (globalBGM.url) {
                        // BGM은 별도 트랙으로 추가하는 것이 더 안정적일 수 있으나 여기서는 믹싱
                    }

                    // TTS + SFX
                    for(const card of scriptCards) {
                        if (card.audioUrl) {
                            const response = await fetch(card.audioUrl);
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            const source = audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(destination);
                            source.start(totalDuration);
                        }
                        if (card.sfxUrl) {
                            const response = await fetch(card.sfxUrl);
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            const source = audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(destination);
                            source.start(totalDuration);
                        }
                        totalDuration += card.duration || 0.5;
                    }

                    const canvasStream = canvas.captureStream(30); // 30fps
                    const combinedStream = new MediaStream([
                        ...canvasStream.getVideoTracks(),
                        ...destination.stream.getAudioTracks()
                    ]);
                    
                    const recorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm;codecs=vp9,opus' });
                    const chunks = [];
                    recorder.ondataavailable = e => chunks.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'sunsak-video-1080p.webm';
                        a.click();
                        URL.revokeObjectURL(url);
                        progressOverlay.style.display = 'none';
                        exportBtn.disabled = false;
                    };
                    
                    recorder.start();

                    // 프레임 렌더링 루프
                    progressText.textContent = '프레임 렌더링 중... (0%)';
                    let currentTime = 0;
                    let currentCardIndex = 0;
                    const frameDuration = 1 / 30; // 30fps

                    const renderLoop = async () => {
                        if (currentTime >= totalDuration) {
                            recorder.stop();
                            return;
                        }

                        // 현재 시간에 맞는 카드 찾기
                        let timeTally = 0;
                        for(let i = 0; i < scriptCards.length; i++) {
                            timeTally += scriptCards[i].duration;
                            if (currentTime < timeTally) {
                                currentCardIndex = i;
                                break;
                            }
                        }
                        
                        await renderFrame(ctx, scriptCards[currentCardIndex], imageCache);
                        
                        currentTime += frameDuration;
                        const progress = Math.min(100, (currentTime / totalDuration) * 100);
                        progressText.textContent = `프레임 렌더링 중... (${Math.round(progress)}%)`;
                        progressBarInner.style.width = `${progress}%`;
                        
                        setTimeout(renderLoop, frameDuration * 1000);
                    };

                    renderLoop();

                } catch (error) {
                    console.error('영상 생성 오류:', error);
                    alert(`영상 생성 중 오류가 발생했습니다: ${error.message}`);
                    progressOverlay.style.display = 'none';
                    exportBtn.disabled = false;
                }
            });
        }
        
        // --- 애플리케이션 초기화 ---
        function initialize() {
            // ... (이전과 동일한 초기화 로직)
            renderControls();
            updatePreviewDisplay();
            addCardBtn.addEventListener('click', () => addScriptCard(''));
            newProjectBtn.addEventListener('click', () => { if(confirm('정말로 새 프로젝트를 시작하시겠습니까? 모든 작업 내용이 사라집니다.')) { location.reload(); } });
            playAllBtn.addEventListener('click', togglePlay);
            setupGptsModal();
            setupExportButton(); // ✨ 새로 만든 함수 호출
            new Sortable(cardContainer, { /* ... */ });
            initializeInteract();
            addScriptCard('SunsakTool에 오신 것을 환영합니다!');
        }
        
        // 이전 코드의 모든 함수를 여기에 포함시켜야 합니다.
        // 예시로 생략된 함수가 많으니 전체 코드를 복사해서 사용하세요.
        initialize();
    });
    </script>
</body>
</html>
