<!DOCTYPE html>
<html lang="ko">
<head>
   <meta charset="UTF-8">
<!-- [ì´ ìµœì¢… ì½”ë“œë¡œ <meta> íƒœê·¸ë¥¼ êµì²´í•˜ì„¸ìš”] -->
<meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com;
    img-src 'self' blob: data:;
    media-src 'self' blob: data: https://sunsaktool-final.netlify.app;
    connect-src 'self' https://sunsaktool-service-741834545202.asia-northeast3.run.app https://sunsaktool-final.netlify.app https://fonts.googleapis.com https://fonts.gstatic.com https://cdn.jsdelivr.net blob: data:;
">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SunsakTool (ìˆœì‚­íˆ´)</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=IBM+Plex+Sans+KR:wght@400;700&family=Gowun+Dodum&family=Gowun+Batang&family=Nanum+Myeongjo:wght@400;700;800&family=Do+Hyeon&family=Black+Han+Sans&family=Gaegu:wght@400;700&family=Hi+Melody&family=Noto+Serif+KR:wght@400;700;900&family=Dokdo&display=swap');
        @font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff') format('woff'); font-weight: 400; }
        @font-face { font-family: 'Spoqa Han Sans Neo'; src: url('https://cdn.jsdelivr.net/gh/spoqa/spoqa-han-sans@latest/Subset/SpoqaHanSansNeo/SpoqaHanSansNeo-Regular.woff2') format('woff2'); font-weight: 400; }
        @font-face { font-family: 'GmarketSans'; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff'); }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideInUp { from { transform: translate3d(0, 50px, 0); opacity: 0; } to { transform: translate3d(0, 0, 0); opacity: 1; } }
        @keyframes slideOutDown { from { transform: translate3d(0, 0, 0); opacity: 1; } to { transform: translate3d(0, 50px, 0); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0.8); opacity: 0; } }

        .is-animating { animation-fill-mode: both; }
        .fadeIn { animation-name: fadeIn; }
        .fadeOut { animation-name: fadeOut; }
        .slideInUp { animation-name: slideInUp; }
        .slideOutDown { animation-name: slideOutDown; }
        .zoomIn { animation-name: zoomIn; }
        .zoomOut { animation-name: zoomOut; }

        :root { --st-accent-color: #e82c43; --st-bg-color: #1e1e1e; --st-panel-color: #2a2a2a; --st-border-color: #383838; --st-text-color: #e0e0e0; --st-subtext-color: #aaa; --st-interact-color: #4a90e2;}
        * { box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--st-bg-color); color: var(--st-text-color); display: flex; height: 100vh; margin: 0; overflow: hidden; -webkit-font-smoothing: antialiased; }
        body.interaction-active { user-select: none; -webkit-user-select: none; }
        .st-panel { height: 100vh; display: flex; flex-direction: column; }
        .st-sidebar { width: 280px; background-color: var(--st-panel-color); padding: 20px; border-right: 1px solid var(--st-border-color); overflow-y: auto;}
        .st-main-container { flex-grow: 1; display: flex; flex-direction: column; }
        .st-top-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background-color: var(--st-panel-color); border-bottom: 1px solid var(--st-border-color); flex-shrink: 0; height: 50px;}
        .st-logo { font-family: 'GmarketSans', sans-serif; font-weight: bold; }
        .st-main-content { display: flex; flex-grow: 1; overflow: hidden; }
        .st-preview-area { flex-basis: 460px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        .st-editor-area { flex-grow: 1; border-left: 1px solid var(--st-border-color); overflow-y: auto; padding: 20px; }
        button { background-color: var(--st-accent-color); color: #fff; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; padding: 8px 12px; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        .st-preview-panel { width: 100%; max-width: 420px; aspect-ratio: 9 / 16; background-color: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; position: relative; transition: transform 0.3s ease; }
        .st-preview-header { position:relative; display: flex; align-items: center; justify-content: center; font-family: 'GmarketSans', sans-serif; color: white; font-weight: bold; flex-shrink: 0; height: 65px; padding: 0 15px; overflow: hidden; }
        .header-icon { position: absolute; left: 15px; display: flex; align-items: center; }
        .header-title { flex-grow: 1; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 0 45px; }
        .header-logo-container { position: absolute; right: 15px; display: flex; align-items: center; }
        .header-icon svg { width: 24px; height: 24px; }
        .header-logo { border-radius: 50%; object-fit: cover; background-color: #eee; }
        .st-preview-content { padding: 10px; color: black; flex-grow: 1; display: flex; flex-direction: column; background-color: white; overflow: hidden; position: relative; }
        .st-project-info { font-size: 13px; color: #555; margin: 0 0 16px 0; border-bottom: 1px solid #eee; padding-bottom: 16px; flex-shrink: 0; }
        .st-project-info .title { font-size: 22px; color: black; font-weight: bold; margin-bottom: 5px; }
        /* Ctrl+F ë¡œ .st-preview-content ë¥¼ ì°¾ìœ¼ì„¸ìš” */
.st-preview-content {
    padding: 10px;
    color: black;
    flex-grow: 1; /* ë³µì›! */
    display: flex;
    flex-direction: column;
    background-color: white;
    overflow: hidden;
    position: relative;
}
.st-script-display {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        min-height: 0;
        width: 100%;
    }
        .interactive-target { position: relative; width: 100%; touch-action: none; transform-origin: center center; cursor: move; }
        #st-preview-media-container-wrapper {
            margin-top: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            flex-grow: 1;
            min-height: 0;
        }
        #st-preview-image, #st-preview-video { max-width: 100%; max-height: 100%; object-fit: contain; }
        .interactive-target.interactive-active { outline: 2px dashed var(--st-interact-color); z-index: 100; }
        #st-preview-text { width: 100%; font-size: 24px; color: #000; white-space: pre-wrap; flex-shrink: 0; }
        .st-timeline-controls { width: 100%; max-width: 420px; display: flex; align-items: center; gap: 10px; margin-top: 15px;}
        .st-play-all-btn { background: none; font-size: 24px; padding: 0;}
        #st-timeline-slider { flex-grow: 1; }
        .st-editor-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .st-card { background-color: var(--st-panel-color); border: 2px solid transparent; padding: 15px; margin-top: 15px; border-radius: 4px; cursor: pointer; position: relative; }
        .st-card.active { border-color: var(--st-accent-color); }
        .st-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .st-card-drag-handle { cursor: grab; }
        .st-card-number { font-weight: bold; font-size: 18px; }
        .st-editor-tip { font-size: 13px; color: var(--st-subtext-color); background-color: #252525; padding: 8px; border-radius: 4px; text-align: center; }
        .st-script-editor { width: 100%; min-height: 60px; background-color: #333; border: 1px solid var(--st-border-color); color: var(--st-text-color); border-radius: 4px; padding: 8px; outline: none; white-space: pre-wrap; }
        .st-script-editor .script-segment { cursor: grab; padding: 2px 0; }
        .preview-text-segment { opacity: 0; transition: opacity 0.3s ease; }
        .preview-text-segment.highlight { opacity: 1; }
        .st-card-footer { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        .st-card-footer .footer-row { display: flex; align-items: center; gap: 10px; font-size: 13px; flex-wrap: wrap; }
        .st-card-footer .st-duration-label { cursor: pointer; text-decoration: underline; }
        .st-card-footer .st-duration-input { width: 60px; padding: 2px 4px; }
        input[type="file"] { display: none; }
        .st-action-btn { background: none; border:none; color: var(--st-subtext-color); text-decoration: underline; cursor: pointer; padding: 0; font-size: 13px; }
        .st-play-clip-btn { font-size: 18px; background: none; padding: 0 5px; cursor: pointer; border: none; color: var(--st-text-color); }
        .st-play-clip-btn:disabled { color: #555; cursor: not-allowed; }
        .st-card-loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; justify-content: center; align-items: center; z-index: 10; border-radius: 4px; font-weight: bold; }
        .st-accordion-header { padding: 12px 0; cursor: pointer; border-bottom: 1px solid var(--st-border-color); font-weight: bold; }
        .st-accordion-content { padding: 15px 0; display: none; }
        .st-accordion-item.active .st-accordion-content { display: block; }
        .st-control-group { margin-bottom: 15px; }
        .st-control-group h4 { margin-top: 0; margin-bottom: 10px; color: var(--st-subtext-color); border-bottom: 1px solid var(--st-border-color); padding-bottom: 8px; }
        .st-control-group label { display: block; margin-bottom: 4px; font-size: 14px; }
        input, select { width: 100%; padding: 8px; background-color: #1e1e1e; border: 1px solid var(--st-border-color); color: var(--st-text-color); border-radius: 4px; }
        .st-flex-group { display: flex; gap: 10px; align-items: center; }
        .st-flex-group label { margin-bottom: 0; }
        .st-flex-group input[type="number"].value-input { width: 70px; text-align: right; padding: 4px 8px; }
        .st-modal-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .st-modal-overlay.visible { display: flex; }
        .st-modal-dialog { background-color: var(--st-panel-color); padding: 24px; border-radius: 8px; width: 90%; max-width: 600px; border: 1px solid var(--st-border-color); display: flex; flex-direction: column; max-height: 90vh; }
        .st-modal-dialog .st-modal-content { overflow-y: auto; flex-grow: 1; }
        .st-modal-dialog textarea#st-gpts-textarea { width: 100%; min-height: 200px; background-color: #333; border-color: var(--st-border-color); color: var(--st-text-color); padding: 8px; border-radius: 4px; }
        .st-modal-dialog .st-modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 24px; flex-shrink: 0; }
        .waveform-container { width: 100%; height: 128px; background-color: #1e1e1e; position: relative; }
        #st-video-trim-preview { width: 100%; max-height: 300px; background-color: #000; margin-bottom: 15px; }
        #st-video-trim-preview video { width: 100%; height: 100%; object-fit: contain; }
        .waveform-loading { text-align: center; padding: 40px; color: var(--st-subtext-color); }
        .waveform-controls { display: flex; justify-content: space-around; align-items: center; margin-top: 10px; flex-shrink: 0; }
        .frame-controls { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 10px; flex-shrink: 0; }
        .frame-controls button { font-size: 18px; padding: 2px 10px; background-color: #444; line-height: 1; }
        #st-export-progress-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; color: white; display: none; flex-direction: column; justify-content: center; align-items: center; font-size: 24px; }
        #st-export-progress-text { font-weight: bold; margin-bottom: 10px; }
        #st-export-progress-subtext { font-size: 16px; color: var(--st-subtext-color); }
        #st-export-progress-bar { width: 80%; max-width: 400px; height: 20px; background: #555; margin-top: 20px; border-radius: 10px; overflow: hidden; }
        #st-export-progress-bar-inner { width: 0%; height: 100%; background: var(--st-accent-color); transition: width 0.1s linear; }
        .st-app-footer { position: fixed; bottom: 0; left: 0; width: 100%; text-align: center; font-size: 12px; padding: 5px; background-color: var(--st-bg-color); color: var(--st-subtext-color); z-index: 1; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: #555; border-radius: 5px; outline: none; padding: 0; margin: auto 0; cursor: pointer; flex-grow: 1; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--st-accent-color); border-radius: 50%; border: 2px solid #fff; margin-top: -5px; }
        #st-sequence-menu { position: fixed; z-index: 1001; background-color: var(--st-panel-color); border: 1px solid var(--st-border-color); border-radius: 5px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); list-style: none; padding: 5px 0; margin: 0; font-size: 14px; }
        #st-sequence-menu li { padding: 8px 15px; cursor: pointer; }
        #st-sequence-menu li:hover { background-color: var(--st-accent-color); color: white; }
        #st-sequence-menu hr { border: none; border-top: 1px solid var(--st-border-color); margin: 5px 0; }
        .tts-settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

        /* ====== ëª¨ë°”ì¼ ë°˜ì‘í˜• CSS ====== */
        @media (max-width: 768px) {
            body {
                overflow-y: auto; 
                flex-direction: column;
                height: auto;
            }

            .st-main-content {
                flex-direction: column;
                overflow: visible;
            }

            .st-sidebar {
                display: none; 
            }
            
            .st-main-container {
                height: auto;
            }

            .st-preview-area {
                flex-basis: auto;
                width: 100%;
                padding: 10px;
                order: 1; /* ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìœ„ë¡œ */
            }

            .st-editor-area {
                width: 100%;
                border-left: none;
                border-top: 2px solid var(--st-border-color);
                height: auto;
                min-height: 50vh;
                order: 2; /* í¸ì§‘ê¸°ë¥¼ ì•„ë˜ë¡œ */
            }

            .st-top-header .st-logo {
                display: none;
            }
            
            .st-top-header {
                justify-content: center;
            }
            
            .st-editor-header .button-group {
                flex-wrap: wrap;
                gap: 5px;
                justify-content: center;
                margin-top: 10px;
            }

            .st-editor-header {
                flex-direction: column;
            }
            
            body.is-rendering .st-preview-panel {
                 transform: scale(0.3) translate(-110%, -110%) !important;
                 transform-origin: top left !important;
            }
        }
       /* í—¤ë” ê¹œë¹¡ì„ ë°©ì§€ìš© CSS */
        .st-preview-header .header-title:empty {
            visibility: hidden;
        }
    </style>
</head>
<body>
   <div id="st-guide-vertical" style="position: fixed; display: none; width: 1px; height: 100%; background-color: var(--st-accent-color); top: 0; z-index: 1002;"></div>
    <div id="st-guide-horizontal" style="position: fixed; display: none; height: 1px; width: 100%; background-color: var(--st-accent-color); left: 0; z-index: 1002;"></div>
    <div class="st-panel st-sidebar" id="st-sidebar-container"> <div id="st-global-settings-panel"></div> <div id="st-animation-settings-panel" style="display: none;"></div> </div>
    <div class="st-main-container">
        <div class="st-top-header"> <div class="st-logo">SunsakTool</div> <button id="st-btn-export-video">ğŸ¬ ì˜ìƒ ì €ì¥</button> </div>
        <div class="st-main-content">
            <div class="st-panel st-preview-area">
                <div class="st-preview-panel" id="st-preview-panel">
                     <div class="st-preview-header"><div class="header-icon"></div><div class="header-title"></div><div class="header-logo-container"><img class="header-logo"></div></div>
                     <div class="st-preview-content" id="st-preview-content">
                         <div class="st-project-info"><div class="title"></div><span></span></div>
                         <div class="st-script-display">
                            <div id="st-preview-text-container-wrapper" class="interactive-target" data-layout-key="text"><div id="st-preview-text"></div></div>
                            <div id="st-preview-media-container-wrapper" class="interactive-target" data-layout-key="media" style="display: none;">
                                <img id="st-preview-image" style="display: none;">
                                <video id="st-preview-video" style="display: none;" muted playsinline></video>
                            </div>
                         </div>
                     </div>
                </div>
                <div class="st-timeline-controls"> <button class="st-play-all-btn" id="st-btn-play-all">â–¶</button> <input type="range" id="st-timeline-slider" value="0" step="0.1"> </div>
            </div>
            <div class="st-panel st-editor-area">
                <div class="st-editor-header"> <h3>ìŠ¤í¬ë¦½íŠ¸ & íƒ€ì„ë¼ì¸</h3> <div class="button-group"> <button id="st-btn-add-project" style="background-color: #555;">+ ìƒˆ í”„ë¡œì íŠ¸</button> <button id="st-btn-add-gpts" style="background-color: #3e3e3e;">âœ¨ ìë™ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± (AI í™œìš©)</button> <button id="st-btn-add-card">+ ìˆ˜ë™ ì¶”ê°€</button> </div> </div>
                <div class="st-editor-tip">ğŸ’¡ Tip: ìŠ¤í¬ë¦½íŠ¸ì˜ ê¸€ì„ ë“œë˜ê·¸í•˜ì—¬ ì˜ìƒì— ë‚˜ì˜¤ëŠ” ìˆœì„œë¥¼ ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!</div>
                <div id="st-card-container"></div>
            </div>
        </div>
    </div>
    <div class="st-app-footer">Pro-Tip: ì›¹ì˜ ì´ë¯¸ì§€ë¥¼ ë³µì‚¬(Ctrl+C)í•œ í›„, ì¹´ë“œë¥¼ í´ë¦­í•˜ê³  ë¶™ì—¬ë„£ê¸°(Ctrl+V) í•´ë³´ì„¸ìš”!</div>
    <ul id="st-sequence-menu" style="display: none;"></ul>
    <div id="st-modal-gpts" class="st-modal-overlay"> <div class="st-modal-dialog"> <div class="st-modal-content"> <h2>AI ëŒ€ë³¸ ë¶™ì—¬ë„£ê¸°</h2> <p>AI íˆ´(ChatGPT, Claude ë“±)ì—ì„œ ìƒì„±ëœ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ë¹ˆ ì¤„ë¡œ êµ¬ë¶„í•˜ì—¬ ì—¬ëŸ¬ ìŠ¤í¬ë¦½íŠ¸ë¥¼ í•œë²ˆì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p> <textarea id="st-gpts-textarea" placeholder="ì—¬ê¸°ì— AI ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."></textarea> </div> <div class="st-modal-actions"> <button id="st-btn-gpts-cancel" class="cancel">ì·¨ì†Œ</button> <button id="st-btn-gpts-confirm">í™•ì¸</button> </div> </div> </div>
    <div id="st-modal-bgm" class="st-modal-overlay"> <div class="st-modal-dialog"> <div class="st-modal-content"> <h2>BGM êµ¬ê°„ ì„¤ì •</h2> <p>íƒ€ì„ë¼ì¸ ìœ„ì—ì„œ ì›í•˜ëŠ” êµ¬ê°„ì„ ë“œë˜ê·¸í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.</p> <div id="st-waveform-container-bgm" class="waveform-container"> <div class="waveform-loading">BGM ë¡œë”© ì¤‘...</div> </div> </div> <div class="waveform-controls"> <button id="st-btn-bgm-play-pause">ì¬ìƒ/ì¼ì‹œì •ì§€</button> <button id="st-btn-bgm-play-region">ì„ íƒ êµ¬ê°„ ë¯¸ë¦¬ë“£ê¸°</button> <span id="st-bgm-time-display">0.00s - 0.00s</span> </div> <div class="st-modal-actions"> <button id="st-btn-bgm-cancel" class="cancel">ì·¨ì†Œ</button> <button id="st-btn-bgm-confirm">í™•ì¸</button> </div> </div> </div>
    <div id="st-modal-video-trim" class="st-modal-overlay"> <div class="st-modal-dialog"> <div class="st-modal-content"> <h2>ë¹„ë””ì˜¤ êµ¬ê°„ ì„ íƒ</h2> <div id="st-video-trim-preview"><video controls></video></div> <p>íƒ€ì„ë¼ì¸ ìœ„ì—ì„œ ì‚¬ìš©í•  êµ¬ê°„ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜, ì–‘ ëì„ ì¡°ì ˆí•˜ì„¸ìš”.</p> <div id="st-waveform-container-video" class="waveform-container"> <div class="waveform-loading">ë¹„ë””ì˜¤ ë¡œë”© ì¤‘...</div> </div> </div> <div class="frame-controls"> <button id="st-btn-video-frame-prev" title="í•œ í”„ë ˆì„ ë’¤ë¡œ"><</button> <span>í”„ë ˆì„ ì´ë™</span> <button id="st-btn-video-frame-next" title="í•œ í”„ë ˆì„ ì•ìœ¼ë¡œ">></button> </div> <div class="waveform-controls"> <button id="st-btn-video-play-region">ì„ íƒ êµ¬ê°„ ë¯¸ë¦¬ë³´ê¸°</button> <span id="st-video-time-display">0.00s - 0.00s</span> </div> <div class="st-modal-actions"> <button id="st-btn-video-cancel" class="cancel">ì·¨ì†Œ</button> <button id="st-btn-video-confirm">í™•ì¸</button> </div> </div> </div>
    <div id="st-export-progress-overlay"> <div id="st-export-progress-text">ì˜ìƒ ìƒì„± ì¤‘...</div> <div id="st-export-progress-subtext"></div> <div id="st-export-progress-bar"><div id="st-export-progress-bar-inner"></div></div> </div>
    <canvas id="st-render-canvas" style="display: none;"></canvas>
    <audio id="st-tts-player" style="display:none;"></audio>
    <audio id="st-bgm-player" style="display:none;" loop></audio>
    <audio id="st-sfx-player" style="display:none;"></audio>
    <input type="file" id="st-sfx-file-upload" accept="audio/*" style="display: none;">
    <input type="file" id="st-bgm-file-upload" accept="audio/*" style="display: none;">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.4.0/wavesurfer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.4.0/plugin/wavesurfer.regions.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script>
    (function SunsakTool() {
        'use strict';

        const C = {
            FONT_LIST: [ { name: 'í”„ë¦¬í…ë‹¤ë“œ (ë³¸ë¬¸ìš© ì¶”ì²œ)', value: 'Pretendard' }, { name: 'Noto Sans KR (ê¸°ë³¸ ê³ ë”•)', value: "'Noto Sans KR', sans-serif" }, { name: 'Gë§ˆì¼“ ì‚°ìŠ¤ (ê°œì„±ìˆëŠ” ì œëª©)', value: 'GmarketSans' }, { name: 'IBM Plex Sans KR (ëª¨ë˜í•œ ê³ ë”•)', value: "'IBM Plex Sans KR', sans-serif" }, { name: 'Do Hyeon (ë ˆíŠ¸ë¡œ ì œëª©)', value: "'Do Hyeon', sans-serif" }, { name: 'ë‚˜ëˆ”ëª…ì¡° (ê°ì„±ì ì¸ ë³¸ë¬¸)', value: "'Nanum Myeongjo', serif" }, { name: 'ê³ ìš´ ë°”íƒ• (ë¶€ë“œëŸ¬ìš´ ëª…ì¡°)', value: "'Gowun Batang', serif" }, { name: 'Black Han Sans (ê°•ë ¥í•œ ì œëª©)', value: "'Black Han Sans', sans-serif" }, { name: 'ê°œêµ¬ (ê·€ì—¬ìš´ ì†ê¸€ì”¨)', value: "'Gaegu', cursive" }, { name: 'Hi Melody (ì•„ê¸°ìê¸° ì†ê¸€ì”¨)', value: "'Hi Melody', cursive" }, { name: 'Noto Serif KR (ì •ê°ˆí•œ ëª…ì¡°)', value: "'Noto Serif KR', serif" }, { name: 'ìŠ¤í¬ì¹´ í•œ ì‚°ìŠ¤ ë„¤ì˜¤ (ê¹”ë”í•œ ë³¸ë¬¸)', value: "'Spoqa Han Sans Neo', sans-serif" }, { name: 'ë…ë„ (ê±°ì¹œ ë¶“ê¸€ì”¨)', value: "'Dokdo', cursive" }, ],
            BGM_LIST: [ { name: 'ì„ íƒ ì•ˆí•¨', url: '' }, { name: 'big-cafe', url: 'https://sunsaktool-final.netlify.app/big-cafe.mp3' }, { name: 'blue-jacket', url: 'https://sunsaktool-final.netlify.app/blue-jacket.mp3' }, { name: 'cute-puppy', url: 'https://sunsaktool-final.netlify.app/cute-puppy.mp3' }, { name: 'laughter-in-the-breeze', url: 'https://sunsaktool-final.netlify.app/laughter-in-the-breeze-_happy_.mp3' }, { name: 'murder-in-my-mind', url: 'https://sunsaktool-final.netlify.app/murder-in-my-mind.mp3' }, { name: 'smiley-composure', url: 'https://sunsaktool-final.netlify.app/smiley-composure.mp3' }, { name: 'spider', url: 'https://sunsaktool-final.netlify.app/spider.mp3' }, { name: 'white-color', url: 'https://sunsaktool-final.netlify.app/white-color.mp3' } ],
            ANIMATIONS: [ { name: 'ì—†ìŒ', value: 'none' }, { name: 'ë‚˜íƒ€ë‚˜ê¸° (Fade In)', value: 'fadeIn' }, { name: 'ì‚¬ë¼ì§€ê¸° (Fade Out)', value: 'fadeOut' }, { name: 'ì•„ë˜ì—ì„œ ìœ„ë¡œ (Slide In Up)', value: 'slideInUp' }, { name: 'ì•„ë˜ë¡œ ì‚¬ë¼ì§€ê¸° (Slide Out Down)', value: 'slideOutDown' }, { name: 'í™•ëŒ€ë˜ë©° ë‚˜íƒ€ë‚˜ê¸° (Zoom In)', value: 'zoomIn' }, { name: 'ì¶•ì†Œë˜ë©° ì‚¬ë¼ì§€ê¸° (Zoom Out)', value: 'zoomOut' } ]
        };
        const state = {
            sfxList: [{ name: "íš¨ê³¼ìŒ ëª©ë¡ ë¡œë”© ì¤‘...", url: "" }],
            recentlyUsedSfx: [],
            sfxUploadTargetCardId: null,
            globalBGM: { url: null, volume: 0.3, startTime: 0, endTime: null },
            projectSettings: { 
                header: { text: 'ì±„ë„ ì´ë¦„', backgroundColor: '#e82c43', color: '#ffffff', fontFamily: 'GmarketSans', fontSize: 24, icon: 'none', logo: { url: null, size: 40 } }, 
                project: { title: 'ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”', author: 'ã…‡ã…‡', views: 0, titleColor: '#000000', metaColor: '#555555', titleFontFamily: "'Noto Sans KR', sans-serif", titleFontSize: 22 },
                defaultStyle: { color: '#000000', fontFamily: "'Noto Sans KR', sans-serif", fontSize: '24', lineHeight: '1.5', letterSpacing: '0', textAlign: 'center' } // textAlign: 'center' ì¶”ê°€
            },
            scriptCards: [],
            isPlaying: false,
            ttsCache: new Map(),
            mediaElementCache: new Map(),
            playbackCurrentIndex: 0,
            selectedCardId: null,
            activeInteractiveElement: null,
            playbackTimeoutId: null,
            currentSelectionContext: null,
            currentPersistentMedia: null,
            bgmWavesurfer: null,
            videoWavesurfer: null,
            activeBgmRegion: null,
            activeVideoRegion: null,
            bgmEditorContext: { onConfirm: null, onCancel: null },
            videoTrimmerContext: { cardId: null, url: null, activeHandle: 'end' },
            audioContext: null,
        };
        const UI = {
            cardContainer: document.getElementById('st-card-container'),
            playAllBtn: document.getElementById('st-btn-play-all'),
            timelineSlider: document.getElementById('st-timeline-slider'),
            ttsPlayer: document.getElementById('st-tts-player'),
            bgmPlayer: document.getElementById('st-bgm-player'),
            sfxPlayer: document.getElementById('st-sfx-player'),
            globalSettingsPanel: document.getElementById('st-global-settings-panel'),
            animationSettingsPanel: document.getElementById('st-animation-settings-panel'),
            addCardBtn: document.getElementById('st-btn-add-card'),
            addGptsBtn: document.getElementById('st-btn-add-gpts'),
            newProjectBtn: document.getElementById('st-btn-add-project'),
            gptsModal: document.getElementById('st-modal-gpts'),
            gptsCancelBtn: document.getElementById('st-btn-gpts-cancel'),
            gptsConfirmBtn: document.getElementById('st-btn-gpts-confirm'),
            gptsTextarea: document.getElementById('st-gpts-textarea'),
            bgmModal: document.getElementById('st-modal-bgm'),
            videoTrimModal: document.getElementById('st-modal-video-trim'),
            sfxFileInput: document.getElementById('st-sfx-file-upload'),
            bgmFileInput: document.getElementById('st-bgm-file-upload'),
            sequenceMenu: document.getElementById('st-sequence-menu'),
            previewContent: document.getElementById('st-preview-content'),
            exportBtn: document.getElementById('st-btn-export-video'),
            progressOverlay: document.getElementById('st-export-progress-overlay'),
            progressText: document.getElementById('st-export-progress-text'),
            progressSubText: document.getElementById('st-export-progress-subtext'),
            progressBarInner: document.getElementById('st-export-progress-bar-inner'),
            renderCanvas: document.getElementById('st-render-canvas')
        };
        const helpers = {
            debounce: (callback, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => callback(...args), delay); }; },
            getAudioDuration: (url, playbackRate = 1.0) => new Promise(resolve => { const audio = new Audio(); audio.onloadedmetadata = () => resolve(audio.duration / playbackRate); audio.onerror = () => resolve(0.5); audio.src = url; }),
            generateId: (prefix = 'id') => `${prefix}-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
            getGroupKey: (name) => { const keywords = ['ë¬¼ë°©ìš¸','í´ë¦­','ë“±ì¥','ì•Œë¦¼','íƒ€ê²©','ê²Œì„','ìŠ¤ìœ•','ë„˜ì–´ê°€ëŠ”','ë„˜ê¸°ëŠ”','ì¢…ì´','ì¹´íˆ°','í­ë°œ','íŒ¡íŒŒë ˆ','ìŠ¤ìš°','ê¹œì§','ì „ììŒ']; for (const key of keywords) { if (name.includes(key)) return key; } return 'ê¸°íƒ€'; }
        };
const SERVICE_URL = 'https://sunsaktool-service-741834545202.asia-northeast3.run.app';
        async function fetchTTS(cardId) {
    const cardData = state.scriptCards.find(c => c.id === cardId);
    if (!cardData || !cardData.text.trim()) return null;
    
    // [ìˆ˜ì •] ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ElevenLabs ì„¤ì • ëŒ€ì‹ , í˜„ì¬ ì‚¬ìš©í•˜ëŠ” ê°’ìœ¼ë¡œ ìºì‹œ í‚¤ë¥¼ ë§Œë“­ë‹ˆë‹¤.
    const { text, ttsVoice, ttsSettings } = cardData;
    const cacheKey = `${text.trim()}-${ttsVoice}-${ttsSettings.speed}`;

    if (state.ttsCache.has(cacheKey)) {
        return state.ttsCache.get(cacheKey);
    }

            render.showLoadingOnCard(cardId, true, 'ìŒì„± ìƒì„± ì¤‘...');
            try {
                const payload = {
                      text: text.trim(),
                      voice: cardData.ttsVoice, // ì‚¬ìš©ìê°€ ì„ íƒí•œ ëª©ì†Œë¦¬ ì´ë¦„ ì¶”ê°€
                      speed: cardData.ttsSettings.speed // ì‚¬ìš©ìê°€ ì¡°ì ˆí•œ ì†ë„ ê°’ ì¶”ê°€
               };
                // [ìˆ˜ì •] fetch ê²½ë¡œë¥¼ SERVICE_URL ìƒìˆ˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
        const response = await fetch(`${SERVICE_URL}/api/create-tts`, { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify(payload) 
        });
                if (!response.ok) { const errorResult = await response.json(); throw new Error(`[${response.status}] ${errorResult.error || 'ì„œë²„ ìš”ì²­ ì‹¤íŒ¨'}`); }
                const result = await response.json(); 
                const { audioUrl } = result;
                const duration = await helpers.getAudioDuration(audioUrl);
                const ttsData = { audioUrl, duration };
                state.ttsCache.set(cacheKey, ttsData); 
                return ttsData;
            } catch (error) {
                console.error('TTS ìƒì„± ì˜¤ë¥˜:', error); alert(`ìŒì„± ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`); return null;
            } finally {
                render.showLoadingOnCard(cardId, false);
            }
        }
        const debouncedTTSRequest = helpers.debounce(async (cardId) => {
            const cardData = state.scriptCards.find(c => c.id === cardId); if (!cardData) return;
            
            const ttsData = await fetchTTS(cardId);

            if (ttsData && cardData) {
                const adjustedDuration = ttsData.duration;
                cardData.ttsDuration = adjustedDuration;
                if (!cardData.isDurationManual) {
                    cardData.duration = adjustedDuration;
                }
                cardData.audioUrl = ttsData.audioUrl; 
                cardData.ttsReady = true;

                const allLines = cardData.text.split('\n').filter(line => line.trim());

                if (allLines.length > 0) {
                    const totalChars = allLines.reduce((sum, s) => sum + s.length, 0);
                    let accumulatedTime = 0;
                    cardData.segments = allLines.map(segmentText => {
                        const segmentDuration = totalChars > 0 ? (segmentText.length / totalChars) * adjustedDuration : 0;
                        const segmentTiming = { text: segmentText, startTime: accumulatedTime, duration: segmentDuration };
                        accumulatedTime += segmentDuration;
                        return segmentTiming;
                    });
                } else {
                    cardData.segments = [];
                }
                
                render.updateCardUI(cardId);
                handlers.updateTotalDuration();
            }
        }, 800);
        const render = {
            showPanel(panelToShow) {
                UI.globalSettingsPanel.style.display = 'none'; UI.animationSettingsPanel.style.display = 'none';
                if (panelToShow === 'global') UI.globalSettingsPanel.style.display = 'block';
                else if (panelToShow === 'animation') UI.animationSettingsPanel.style.display = 'block';
            },
            globalControls() {
                const createSelectWithOptions = (id, selectedValue, fontList = C.FONT_LIST) => { let select = `<select id="${id}">`; fontList.forEach(font => { select += `<option value="${font.value}" ${selectedValue === font.value ? 'selected' : ''}>${font.name}</option>`; }); return select + `</select>`; };
                const bgmOptions = C.BGM_LIST.map(bgm => `<option value="${bgm.url}">${bgm.name}</option>`).join('');
                UI.globalSettingsPanel.innerHTML = `<div class="st-accordion-item active"><div class="st-accordion-header">ì˜ìƒ ì„¤ì •</div><div class="st-accordion-content"><div class="st-control-group"><h4>ìƒë‹¨ í—¤ë”</h4><label>í—¤ë” í…ìŠ¤íŠ¸</label><input type="text" id="st-setting-header-text" value="${state.projectSettings.header.text}"><div class="st-flex-group" style="margin-top: 8px;"><div><label>ë°°ê²½ ìƒ‰ìƒ</label><input type="color" id="st-setting-header-bg" value="${state.projectSettings.header.backgroundColor}"></div><div><label>ê¸€ì ìƒ‰ìƒ</label><input type="color" id="st-setting-header-color" value="${state.projectSettings.header.color}"></div></div><div class="st-flex-group" style="margin-top: 8px;"><div><label>í°íŠ¸</label>${createSelectWithOptions('st-setting-header-font', state.projectSettings.header.fontFamily)}</div><div><label>í¬ê¸°</label><input type="number" id="st-setting-header-size" value="${state.projectSettings.header.fontSize}"></div></div><div style="margin-top: 8px;"><label>ì™¼ìª½ ì•„ì´ì½˜</label><select id="st-setting-header-icon"><option value="none">ì—†ìŒ</option><option value="back">ë’¤ë¡œê°€ê¸°</option><option value="menu">ë©”ë‰´</option></select></div><div style="margin-top: 8px;"><label>ì˜¤ë¥¸ìª½ ë¡œê³ </label><div class="st-flex-group"><button id="st-btn-header-logo" style="width: auto; flex-grow: 1;">ë¡œê³  ì¶”ê°€/ë³€ê²½</button><input type="file" id="st-header-logo-file" accept="image/*" style="display:none;"></div><div class="st-flex-group" style="margin-top: 4px;"><label>ë¡œê³  í¬ê¸°:</label><input type="range" id="st-setting-header-logo-size" min="20" max="60" value="${state.projectSettings.header.logo.size}"><input type="number" class="value-input" data-target="st-setting-header-logo-size" value="${state.projectSettings.header.logo.size}" style="width: 70px;"></div></div></div><div class="st-control-group"><h4>ì½˜í…ì¸  ì •ë³´</h4><label>í”„ë¡œì íŠ¸ ì œëª©</label><input type="text" id="st-setting-project-title" value="${state.projectSettings.project.title}"><div class="st-flex-group" style="margin-top: 8px;"><div><label>í°íŠ¸</label>${createSelectWithOptions('st-setting-project-font', state.projectSettings.project.titleFontFamily)}</div><div><label>í¬ê¸°</label><input type="number" id="st-setting-project-size" value="${state.projectSettings.project.titleFontSize}"></div></div><div style="margin-top: 8px;"><label>ì‘ì„±ì</label><input type="text" id="st-setting-project-author" value="${state.projectSettings.project.author}"></div><div style="margin-top: 8px;"><label>ì¡°íšŒìˆ˜</label><input type="number" id="st-setting-project-views" value="${state.projectSettings.project.views}"></div><div class="st-flex-group" style="margin-top: 8px;"><div><label>ì œëª© ìƒ‰ìƒ</label><input type="color" id="st-setting-title-color" value="${state.projectSettings.project.titleColor}"></div><div><label>ì •ë³´ ìƒ‰ìƒ</label><input type="color" id="st-setting-meta-color" value="${state.projectSettings.project.metaColor}"></div></div><hr style="border-color: var(--st-border-color); margin: 15px 0;"><label>ê¸°ë³¸ ìŠ¤í¬ë¦½íŠ¸ ìŠ¤íƒ€ì¼</label><div class="st-flex-group" style="margin-top: 8px;"><div><label>í°íŠ¸</label>${createSelectWithOptions('st-setting-script-font', state.projectSettings.defaultStyle.fontFamily)}</div><div><label>í¬ê¸°</label><input type="number" id="st-setting-script-size" value="${state.projectSettings.defaultStyle.fontSize}"></div></div><div style="margin-top: 8px;"><label>ìƒ‰ìƒ</label><input type="color" id="st-setting-script-color" value="${state.projectSettings.defaultStyle.color}"></div><div style="margin-top: 8px;">
    <label>ì •ë ¬</label>
    <div id="st-text-align-group" class="st-flex-group" style="gap: 5px;">
        <button data-align="left" style="flex-grow: 1;">ì™¼ìª½</button>
        <button data-align="center" style="flex-grow: 1;">ì¤‘ì•™</button>
        <button data-align="right" style="flex-grow: 1;">ì˜¤ë¥¸ìª½</button>
    </div>
</div><div class="st-flex-group" style="margin-top: 8px;"><label>ì¤„ ê°„ê²©</label><input type="range" id="st-setting-line-height" min="1" max="2.5" step="0.1" value="${state.projectSettings.defaultStyle.lineHeight}"><input type="number" class="value-input" data-target="st-setting-line-height" value="${state.projectSettings.defaultStyle.lineHeight}" step="0.1"></div><div class="st-flex-group" style="margin-top: 8px;"><label>ìê°„</label><input type="range" id="st-setting-letter-spacing" min="-2" max="5" step="0.1" value="${state.projectSettings.defaultStyle.letterSpacing}"><input type="number" class="value-input" data-target="st-setting-letter-spacing" value="${state.projectSettings.defaultStyle.letterSpacing}" step="0.1"></div></div><div class="st-control-group"><h4>ë°°ê²½ìŒì•…</h4><label>ì „ì²´ BGM ì„ íƒ</label><select id="st-setting-global-bgm">${bgmOptions}</select><button id="st-btn-upload-bgm" style="width:100%; margin-top: 8px; background-color: #3e3e3e;">ë‚´ BGM ì—…ë¡œë“œ</button><div class="st-flex-group" style="margin-top: 8px;"><label>BGM ë³¼ë¥¨</label><input type="range" id="st-setting-global-bgm-volume" min="0" max="1" step="0.01" value="${state.globalBGM.volume}"><input type="number" class="value-input" data-target="st-setting-global-bgm-volume" value="${Math.round(state.globalBGM.volume * 100)}"></div></div></div></div>`;
                UI.globalSettingsPanel.querySelector('.st-accordion-header').addEventListener('click', (e) => e.currentTarget.parentElement.classList.toggle('active'));
            },
            animationControls(element) {
                if (!state.selectedCardId || !element) return;
                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                const layoutKey = element.dataset.layoutKey; const anims = card.animations[layoutKey];
                const createAnimOptions = (selectedValue) => C.ANIMATIONS.map(a => `<option value="${a.value}" ${selectedValue === a.value ? 'selected' : ''}>${a.name}</option>`).join('');
                const elementType = layoutKey === 'text' ? 'í…ìŠ¤íŠ¸' : 'ë¯¸ë””ì–´';
                UI.animationSettingsPanel.innerHTML = `<h3>${elementType} ì• ë‹ˆë©”ì´ì…˜</h3><div class="st-control-group"><label>ì‹œì‘ ì• ë‹ˆë©”ì´ì…˜ (In)</label><select id="anim-in-type">${createAnimOptions(anims.in.name)}</select><label>ì§€ì† ì‹œê°„ (ì´ˆ)</label><input type="number" id="anim-in-duration" min="0.1" max="5" step="0.1" value="${anims.in.duration}"></div><div class="st-control-group"><label>ì¢…ë£Œ ì• ë‹ˆë©”ì´ì…˜ (Out)</label><select id="anim-out-type">${createAnimOptions(anims.out.name)}</select><label>ì§€ì† ì‹œê°„ (ì´ˆ)</label><input type="number" id="anim-out-duration" min="0.1" max="5" step="0.1" value="${anims.out.duration}"></div>`;
                document.getElementById('anim-in-type').addEventListener('input', e => { anims.in.name = e.target.value; });
                document.getElementById('anim-in-duration').addEventListener('input', e => { anims.in.duration = parseFloat(e.target.value) || 0.5; });
                document.getElementById('anim-out-type').addEventListener('input', e => { anims.out.name = e.target.value; });
                document.getElementById('anim-out-duration').addEventListener('input', e => { anims.out.duration = parseFloat(e.target.value) || 0.5; });
                this.showPanel('animation');
            },
            sfxOptions: () => {
                const groups = {};
                state.sfxList.slice(1).filter(sfx => !state.recentlyUsedSfx.find(recent => recent.url === sfx.url)).forEach(sfx => { const groupKey = helpers.getGroupKey(sfx.name); if (!groups[groupKey]) groups[groupKey] = []; groups[groupKey].push(sfx); });
                let optionsHtml = '<option value="">íš¨ê³¼ìŒ ì—†ìŒ</option><option value="upload-my-own">--- ë‚´ íš¨ê³¼ìŒ ì—…ë¡œë“œ ---</option>';
                if (state.recentlyUsedSfx.length > 0) { optionsHtml += '<optgroup label="ìµœê·¼ ì‚¬ìš©">'; state.recentlyUsedSfx.forEach(sfx => { optionsHtml += `<option value="${sfx.url}">${sfx.name}</option>`; }); optionsHtml += '</optgroup>'; }
                Object.keys(groups).sort().forEach(groupName => { optionsHtml += `<optgroup label="${groupName}">`; groups[groupName].forEach(sfx => { optionsHtml += `<option value="${sfx.url}">${sfx.name}</option>`; }); optionsHtml += '</optgroup>'; });
                return optionsHtml;
            },
            allSfxSelects: () => {
                const newOptions = render.sfxOptions();
                document.querySelectorAll('.st-card').forEach(cardEl => { const id = cardEl.dataset.id; const cardData = state.scriptCards.find(c => c.id === id); const selectEl = cardEl.querySelector('.st-sfx-select'); if (selectEl && cardData) { selectEl.innerHTML = newOptions; selectEl.value = cardData.sfxUrl || ''; } });
            },
                        cardElement: (cardData) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'st-card';
                cardEl.dataset.id = cardData.id;
                const sfxOptions = render.sfxOptions();

                // [ìµœì¢… ìˆ˜ì •] ëª¨ë“  ì¤‘ë³µì´ ì œê±°ë˜ê³ , ì˜¬ë°”ë¥¸ ìˆœì„œë¡œ ì •ë¦¬ëœ HTML
                cardEl.innerHTML = `
                    <div class="st-card-header st-card-drag-handle">
                        <span class="st-card-number"></span>
                        <button class="st-btn-delete-card">ğŸ—‘ï¸</button>
                    </div>
                    <div class="st-script-editor" contenteditable="true" spellcheck="false"></div>
                    <div class="st-card-footer">
                        <div class="footer-row">
                            <button class="st-play-clip-btn" title="ë¯¸ë¦¬ë“£ê¸°" disabled>â–¶ï¸</button>
                            <span class="st-duration-label" title="í´ë¦­í•˜ì—¬ ìë™/ìˆ˜ë™ ì „í™˜">ê¸¸ì´(ìë™)</span>
                            <input type="number" class="st-duration-input" min="0.1" step="0.1" value="${cardData.duration}" title="ê¸¸ì´(ì´ˆ)" style="display: none;">
                            <label class="st-action-btn" for="${cardData.id}-file">ë¯¸ë””ì–´ ì¶”ê°€</label>
                            <input type="file" id="${cardData.id}-file" accept="image/*,video/*">
                        </div>
                        <div class="footer-row media-controls" style="display: none;">
                            <span>ë¯¸ë””ì–´ í‘œì‹œ:</span><select class="media-timing-select"></select>
                            <span>ì§€ì† ì‹œê°„:</span><select class="media-persist-select"></select>
                        </div>
                        <div class="footer-row media-controls" style="display: none;">
                            <span>ë¯¸ë””ì–´ ë§ì¶¤:</span>
                            <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="cover">ê½‰ ì±„ìš°ê¸°</label>
                            <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="contain" checked>ì•ˆì— ë§ì¶”ê¸°</label>
                            <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="fill">ëŠ˜ë¦¬ê¸°</label>
                        </div>
                        
                        <!-- ===== TTS ì»¨íŠ¸ë¡¤ UI ì‹œì‘ (ì˜¬ë°”ë¥¸ ìœ„ì¹˜) ===== -->
                        <div class="footer-row tts-controls">
                            <label>ëª©ì†Œë¦¬ ì„ íƒ</label>
                            <select class="tts-voice-select" style="flex-grow: 1;">
                                <option value="ko-KR-Standard-C">í‘œì¤€ ë‚¨ì„± 1</option>
                                <option value="ko-KR-Standard-D">í‘œì¤€ ë‚¨ì„± 2</option>
                                <option value="ko-KR-Standard-A">í‘œì¤€ ì—¬ì„± 1</option>
                                <option value="ko-KR-Standard-B">í‘œì¤€ ì—¬ì„± 2</option>
                            </select>
                        </div>
                        <div class="footer-row tts-controls">
                            <label>ë³¼ë¥¨</label>
                            <div class="st-flex-group">
                                <input type="range" class="st-volume-slider tts-volume" data-type="tts-volume" data-target-id="${cardData.id}" min="0" max="1" step="0.01" value="${cardData.ttsVolume}">
                                <input type="number" class="value-input" data-type="tts-volume" data-target-id="${cardData.id}" value="${Math.round(cardData.ttsVolume * 100)}">
                            </div>
                        </div>
                        <div class="footer-row tts-controls">
                            <label>ì†ë„</label>
                            <div class="st-flex-group">
                                <input type="range" class="tts-speed-slider" data-target-id="${cardData.id}" min="0.5" max="2" step="0.05" value="${cardData.ttsSettings.speed}">
                                <input type="number" class="value-input tts-speed-input" data-target-id="${cardData.id}" value="${cardData.ttsSettings.speed}" step="0.1">
                            </div>
                        </div>
                        <!-- ===== TTS ì»¨íŠ¸ë¡¤ UI ë ===== -->

                        <div class="footer-row">
                            <label>íš¨ê³¼ìŒ</label>
                            <div class="st-flex-group">
                                <input type="range" class="st-volume-slider sfx-volume" data-type="sfx-volume" data-target-id="${cardData.id}" min="0" max="1" step="0.01" value="${cardData.sfxVolume}">
                                <input type="number" class="value-input" data-type="sfx-volume" data-target-id="${cardData.id}" value="${Math.round(cardData.sfxVolume * 100)}">
                            </div>
                        </div>
                        <div class="footer-row">
                            <select class="st-sfx-select" style="flex-grow: 1;">${sfxOptions}</select>
                        </div>
                    </div>
                    <div class="st-card-loading" style="display: none;"></div>
                `;
                
                cardEl.querySelector('.st-sfx-select').value = cardData.sfxUrl || '';
                return cardEl;
            },
            segmentsInEditor: (editorEl, text) => {
                editorEl.innerHTML = ''; const lines = text.split('\n');
                if (lines.length === 1 && lines[0] === '') { editorEl.innerHTML = '<p class="script-segment"><br></p>'; } 
                else { lines.forEach(line => { const p = document.createElement('p'); p.className = 'script-segment'; p.textContent = line || ' '; editorEl.appendChild(p); }); }
            },
            updateCardUI: (cardId) => {
                const cardData = state.scriptCards.find(c => c.id === cardId);
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardData || !cardEl) return;

                cardEl.querySelector('.st-play-clip-btn').disabled = !cardData.ttsReady;
                cardEl.querySelector('.tts-volume').value = cardData.ttsVolume;
                cardEl.querySelector('.value-input[data-type="tts-volume"]').value = Math.round(cardData.ttsVolume*100);

                cardEl.querySelector('.tts-speed-slider').value = cardData.ttsSettings.speed;
                cardEl.querySelector('.tts-speed-input').value = cardData.ttsSettings.speed.toFixed(2);
                

                cardEl.querySelector('.sfx-volume').value = cardData.sfxVolume;
                cardEl.querySelector('.value-input[data-type="sfx-volume"]').value = Math.round(cardData.sfxVolume*100);
                
                const durationLabel = cardEl.querySelector('.st-duration-label');
                const durationInput = cardEl.querySelector('.st-duration-input');
                durationInput.value = (cardData.duration || 0).toFixed(2);
                durationInput.style.display = cardData.isDurationManual ? 'inline-block' : 'none';
                durationLabel.textContent = `ê¸¸ì´(${cardData.isDurationManual ? 'ìˆ˜ë™' : 'ìë™'})`;
                
                const ttsControls = cardEl.querySelectorAll('.tts-controls');
                ttsControls.forEach(el => el.style.display = cardData.text.trim() ? 'flex' : 'none');

                render.updateMediaControls(cardId);
            },
            updateMediaControls(cardId) {
                const cardData = state.scriptCards.find(c => c.id === cardId);
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardData || !cardEl) return;
                const mediaControls = cardEl.querySelectorAll('.media-controls');
                if (cardData.media.url) {
                    mediaControls.forEach(el => el.style.display = 'flex');
                    const timingSelect = cardEl.querySelector('.media-timing-select');
                    timingSelect.innerHTML = `<option value="1">ìŠ¤í¬ë¦½íŠ¸ ì‹œì‘ ì‹œ</option>`;
                    if (cardData.segments.length > 1) { cardData.segments.forEach((seg, i) => { timingSelect.innerHTML += `<option value="${i + 2}">"${seg.text.substring(0, 10)}..." ì´í›„</option>`; }); }
                    timingSelect.value = cardData.media.showOnSegment;
                    const persistSelect = cardEl.querySelector('.media-persist-select');
                    const currentIndex = state.scriptCards.findIndex(c => c.id === cardId);
                    persistSelect.innerHTML = `<option value="">ì´ í´ë¦½ì—ì„œë§Œ</option>`;
                    if (currentIndex < state.scriptCards.length - 1) { state.scriptCards.slice(currentIndex).forEach((c, i) => { if(i > 0) persistSelect.innerHTML += `<option value="${c.id}">ì¹´ë“œ ${currentIndex + i + 1}ê¹Œì§€</option>`; }); }
                    persistSelect.value = cardData.media.persistUntilCardId || '';
                    const fitRadio = cardEl.querySelector(`input[name="media-fit-${cardId}"][value="${cardData.media.fit}"]`);
                    if (fitRadio) fitRadio.checked = true;
                } else {
                    mediaControls.forEach(el => el.style.display = 'none');
                }
            },
            updateCardNumbers: () => {
                const allCardElements = UI.cardContainer.querySelectorAll('.st-card');
                state.scriptCards.forEach((cardData, index) => { const cardEl = Array.from(allCardElements).find(el => el.dataset.id === cardData.id); if (cardEl) cardEl.querySelector('.st-card-number').textContent = index + 1; });
                state.scriptCards.forEach(card => render.updateMediaControls(card.id));
            },
            showLoadingOnCard: (cardId, show, message = '') => {
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardEl) return; let overlay = cardEl.querySelector('.st-card-loading');
                if (show) { if (!overlay) { overlay = document.createElement('div'); overlay.className = 'st-card-loading'; cardEl.appendChild(overlay); } overlay.style.display = 'flex'; overlay.textContent = message; } 
                else { if (overlay) overlay.style.display = 'none'; }
            },
            applyTransform: (el, layout) => { if (el) { el.style.transform = `translate(${layout.x || 0}px, ${layout.y || 0}px) scale(${layout.scale || 1}) rotate(${layout.angle || 0}deg)`; } },
            updatePreviewDisplay: () => {
                const headerEl = document.querySelector('.st-preview-header');
                const headerIconEl = headerEl.querySelector('.header-icon');
                const headerTitleEl = headerEl.querySelector('.header-title');
                const headerLogoEl = headerEl.querySelector('.header-logo');
                headerTitleEl.textContent = state.projectSettings.header.text;
                headerEl.style.backgroundColor = state.projectSettings.header.backgroundColor;
                headerEl.style.color = state.projectSettings.header.color;
                headerEl.style.fontFamily = state.projectSettings.header.fontFamily;
                headerTitleEl.style.fontSize = state.projectSettings.header.fontSize + 'px';
                const iconSVG = { back: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${state.projectSettings.header.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`, menu: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${state.projectSettings.header.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>` };
                headerIconEl.innerHTML = iconSVG[state.projectSettings.header.icon] || '';
                if (state.projectSettings.header.logo.url) { headerLogoEl.src = state.projectSettings.header.logo.url; headerLogoEl.style.width = state.projectSettings.header.logo.size + 'px'; headerLogoEl.style.height = state.projectSettings.header.logo.size + 'px'; headerLogoEl.style.display = 'block'; } 
                else { headerLogoEl.style.display = 'none'; }
                const titleEl = document.querySelector('.st-project-info .title');
                titleEl.textContent = state.projectSettings.project.title;
                titleEl.style.color = state.projectSettings.project.titleColor;
                titleEl.style.fontFamily = state.projectSettings.project.titleFontFamily;
                titleEl.style.fontSize = state.projectSettings.project.titleFontSize + 'px';
                const metaEl = document.querySelector('.st-project-info span');
                metaEl.textContent = `${state.projectSettings.project.author || ''} | ì¡°íšŒìˆ˜ ${Number(state.projectSettings.project.views || 0).toLocaleString()}`;
                metaEl.style.color = state.projectSettings.project.metaColor;
                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                const textWrapper = document.getElementById('st-preview-text-container-wrapper');
                const previewText = document.getElementById('st-preview-text');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                const previewImage = document.getElementById('st-preview-image');
                const previewVideo = document.getElementById('st-preview-video');
                
                if (!card) {
                    textWrapper.style.display = 'none'; 
                    mediaWrapper.style.display = 'none'; 
                    previewImage.style.display = 'none';
                    previewVideo.style.display = 'none';
                    return; 
                }
                
                textWrapper.style.display = 'block';
                mediaWrapper.style.display = card.media.url ? 'block' : 'none';
                render.applyTransform(textWrapper, card.layout.text);
                render.applyTransform(mediaWrapper, card.layout.media);
                Object.assign(previewText.style, card.style);
                previewText.innerHTML = '';
                const linesToDisplay = card.text.split('\n');
                linesToDisplay.forEach(line => { const p = document.createElement('p'); p.className = 'preview-text-segment highlight'; p.textContent = line || ' '; p.style.margin = 0; previewText.appendChild(p); });
                
                if (card.media.url) {
                    if (card.media.type === 'image') {
                        previewImage.style.display = 'block';
                        previewVideo.style.display = 'none';
                        if (previewImage.src !== card.media.url) previewImage.src = card.media.url;
                        previewImage.style.objectFit = card.media.fit;
                    } else if (card.media.type === 'video') {
                        previewVideo.style.display = 'block';
                        previewImage.style.display = 'none';
                        if (previewVideo.src !== card.media.url) previewVideo.src = card.media.url;
                        previewVideo.style.objectFit = card.media.fit;
                        previewVideo.currentTime = card.media.startTime || 0;
                    }
                } else {
                    previewImage.style.display = 'none';
                    previewVideo.style.display = 'none';
                }
            },
        };
        const playback = {
            // [ì¶”ê°€] ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œì„ í™œì„±í™”í•˜ê³  ì¬ìƒí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
            unlockAndPlayAudio(audioElement) {
                if (!state.audioContext) {
                    try {
                        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.error("AudioContextë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.", e);
                        return;
                    }
                }
                
                // AudioContextê°€ ì ê²¨ ìˆìœ¼ë©´ í’€ì–´ì¤ë‹ˆë‹¤.
                if (state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }

                // ì˜¤ë””ì˜¤ ì¬ìƒ
                audioElement.play().catch(e => console.error("ì˜¤ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜:", e));
            },

            togglePlay: () => { state.isPlaying ? playback.stop() : playback.start(); },
            
            start: (isMutedForRecord = false) => {
                interaction.deactivateAllInteractive();
                const unready = state.scriptCards.some(c => c.text.trim() && !c.ttsReady);
                if (unready) return alert('ì•„ì§ ìŒì„± ìƒì„±ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ìŠ¤í¬ë¦½íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.');
                if (state.scriptCards.length === 0) return;

                // [ìˆ˜ì •] ì¬ìƒ ì‹œì‘ ì‹œ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ í™œì„±í™”í•©ë‹ˆë‹¤.
                // ì‚¬ìš©ìê°€ ë²„íŠ¼ì„ ëˆŒë €ìœ¼ë¯€ë¡œ, ì´ ì‹œì ì— AudioContextë¥¼ ìƒì„±/í™œì„±í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                if (!state.audioContext) {
                    try {
                        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) { console.error("AudioContextë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.", e); }
                }
                if (state.audioContext && state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }

                state.isPlaying = true; UI.playAllBtn.textContent = 'âšâš';
                
                if (!isMutedForRecord) {
                    playback.playBGM();
                }
                
                playback.playCardByIndex(0, isMutedForRecord);
            },

            stop: () => {
                clearTimeout(state.playbackTimeoutId);
                state.isPlaying = false; 
                UI.playAllBtn.textContent = 'â–¶';
                UI.ttsPlayer.pause(); UI.bgmPlayer.pause(); UI.sfxPlayer.pause();
                document.getElementById('st-preview-video').pause();
                
                document.querySelectorAll('.is-animating').forEach(el => el.classList.remove('is-animating', ...C.ANIMATIONS.map(a => a.value)));
                const textWrapper = document.getElementById('st-preview-text-container-wrapper');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                if (textWrapper) {
                    textWrapper.style.animation = '';
                    textWrapper.style.opacity = '1';
                }
                if (mediaWrapper) {
                    mediaWrapper.style.animation = '';
                    mediaWrapper.style.opacity = '1';
                }

                state.currentPersistentMedia = null;
                if(state.selectedCardId) render.updatePreviewDisplay();
            },

            playBGM: (bgmData = state.globalBGM) => {
                if (bgmData && bgmData.url) {
                    if (UI.bgmPlayer.src !== bgmData.url) UI.bgmPlayer.src = bgmData.url;
                    UI.bgmPlayer.volume = state.globalBGM.volume; 
                    UI.bgmPlayer.currentTime = bgmData.startTime || 0;
                    
                    // [ìˆ˜ì •] í—¬í¼ í•¨ìˆ˜ë¥¼ í†µí•´ ì¬ìƒ
                    playback.unlockAndPlayAudio(UI.bgmPlayer);

                    if (bgmData.endTime) { 
                        UI.bgmPlayer.loop = false;
                        UI.bgmPlayer.ontimeupdate = () => { if (UI.bgmPlayer.currentTime >= bgmData.endTime) { UI.bgmPlayer.currentTime = bgmData.startTime || 0; } }; 
                    } else { 
                        UI.bgmPlayer.ontimeupdate = null; 
                        UI.bgmPlayer.loop = true; 
                    }
                } else { UI.bgmPlayer.pause(); }
            },

            playCardByIndex(index, isMutedForRecord = false) {
                if (index >= state.scriptCards.length || !state.isPlaying) { playback.stop(); return; }
                state.playbackCurrentIndex = index;
                const card = state.scriptCards[index];
                handlers.selectCard(card.id, true);

                const textWrapper = document.getElementById('st-preview-text-container-wrapper');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                const previewTextEl = document.getElementById('st-preview-text');
                
                [textWrapper, mediaWrapper].forEach(el => {
                    el.classList.remove('is-animating', ...C.ANIMATIONS.map(a => a.value));
                    el.style.animation = '';
                    el.style.animationDuration = '';
                });

                const applyAnimation = (el, anim) => {
                    if (!el || !anim || anim.name === 'none') return;
                    el.style.animationName = anim.name;
                    el.style.animationDuration = `${anim.duration}s`;
                    el.style.animationFillMode = 'both';
                };
                
                applyAnimation(textWrapper, card.animations.text.in);
                applyAnimation(mediaWrapper, card.animations.media.in);
                
                const outDelay = Math.max(0, (card.duration - Math.max(card.animations.text.out.duration, card.animations.media.out.duration, 0.1))) * 1000;
                setTimeout(() => {
                    if (!state.isPlaying || state.playbackCurrentIndex !== index) return;
                    applyAnimation(textWrapper, card.animations.text.out);
                    applyAnimation(mediaWrapper, card.animations.media.out);
                }, outDelay);

                previewTextEl.innerHTML = '';
                if (card.animationSequence.length > 0) {
                    card.segments.forEach((segment) => {
                        setTimeout(() => {
                            if (state.isPlaying && state.playbackCurrentIndex === index) {
                                const p = document.createElement('p'); p.className = 'preview-text-segment highlight'; p.textContent = segment.text || ' '; p.style.margin = 0;
                                previewTextEl.appendChild(p);
                            }
                        }, segment.startTime * 1000);
                    });
                } else {
                     card.text.split('\n').forEach(line => {
                        const p = document.createElement('p'); p.className = 'preview-text-segment highlight'; p.textContent = line || ' '; p.style.margin = 0; previewTextEl.appendChild(p);
                     });
                }
                
                if (!isMutedForRecord) {
                    // [ìˆ˜ì •] ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ë¯¸ë¦¬ ì„¤ì •í•˜ê³  í—¬í¼ í•¨ìˆ˜ë¡œ ì¬ìƒ
                    if (card.audioUrl) { 
                        UI.ttsPlayer.src = card.audioUrl; 
                        UI.ttsPlayer.volume = card.ttsVolume; 
                        UI.ttsPlayer.playbackRate = card.ttsSettings.speed; 
                        playback.unlockAndPlayAudio(UI.ttsPlayer);
                    }
                    if (card.sfxUrl) { 
                        UI.sfxPlayer.src = card.sfxUrl; 
                        UI.sfxPlayer.volume = card.sfxVolume; 
                        playback.unlockAndPlayAudio(UI.sfxPlayer);
                    }
                }
                
                state.playbackTimeoutId = setTimeout(() => { if (state.isPlaying) playback.playCardByIndex(index + 1, isMutedForRecord); }, card.duration * 1000);
            },
           updatePreviewForFrame(card, timeInCard) {
                const textWrapper = document.getElementById('st-preview-text-container-wrapper');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                const previewTextEl = document.getElementById('st-preview-text');

                [textWrapper, mediaWrapper].forEach(el => {
                    el.style.animation = '';
                });

                render.updatePreviewDisplay();

                Object.assign(document.getElementById('st-preview-text').style, card.style);
                render.applyTransform(textWrapper, card.layout.text);
                render.applyTransform(mediaWrapper, card.layout.media);

                previewTextEl.innerHTML = '';
                if (card.segments && card.segments.length > 0) {
                    card.segments.forEach((segment) => {
                        if (timeInCard >= segment.startTime) {
                            const p = document.createElement('p');
                            p.className = 'preview-text-segment highlight';
                            p.textContent = segment.text || ' ';
                            p.style.margin = 0;
                            previewTextEl.appendChild(p);
                        }
                    });
                } else {
                    card.text.split('\n').forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'preview-text-segment highlight';
                        p.textContent = line || ' ';
                        p.style.margin = 0;
                        previewTextEl.appendChild(p);
                    });
                }
                
                let showMedia = false;
                if (card.media && card.media.url) {
                    const showOnSegmentIndex = (card.media.showOnSegment || 1) - 1;
                    const showTime = (card.segments && card.segments[showOnSegmentIndex]) ? card.segments[showOnSegmentIndex].startTime : 0;
                    if (timeInCard >= showTime) showMedia = true;
                }

                if (showMedia) {
                    mediaWrapper.style.display = 'flex';
                    const imageEl = document.getElementById('st-preview-image');
                    const videoEl = document.getElementById('st-preview-video');
                    if (card.media.type === 'video') {
                        imageEl.style.display = 'none';
                        videoEl.style.display = 'block';
                        videoEl.style.objectFit = card.media.fit;
                        if (videoEl.src !== card.media.url) videoEl.src = card.media.url;
                        videoEl.currentTime = (card.media.startTime || 0) + timeInCard;
                    } else {
                        videoEl.style.display = 'none';
                        imageEl.style.display = 'block';
                        imageEl.style.objectFit = card.media.fit;
                        if (imageEl.src !== card.media.url) imageEl.src = card.media.url;
                    }
                } else {
                    mediaWrapper.style.display = 'none';
                }

                const applyAnimation = (el, anims, duration, time) => {
                    if (!anims) return;
                    const baseTransform = el.style.transform.split(' ').filter(s => !s.startsWith('translateY') && !s.startsWith('scale')).join(' ');
                    el.style.opacity = 1;
                    el.style.transform = baseTransform;
                    const inDuration = anims.in.duration;
                    const outStartTime = duration - anims.out.duration;
                    let progress, newTransform = '';
                    if (time < inDuration && anims.in.name !== 'none') {
                        progress = Math.min(1, time / inDuration);
                        if (anims.in.name === 'fadeIn') el.style.opacity = progress;
                        if (anims.in.name === 'slideInUp') newTransform = ` translateY(${(1 - progress) * 50}px)`;
                        if (anims.in.name === 'zoomIn') {
                            el.style.opacity = progress;
                            newTransform = ` scale(${0.8 + 0.2 * progress})`;
                        }
                    } else if (time >= outStartTime && anims.out.name !== 'none') {
                        progress = Math.min(1, (time - outStartTime) / anims.out.duration);
                        if (anims.out.name === 'fadeOut') el.style.opacity = 1 - progress;
                        if (anims.out.name === 'slideOutDown') newTransform = ` translateY(${progress * 50}px)`;
                        if (anims.out.name === 'zoomOut') {
                            el.style.opacity = 1 - progress;
                            newTransform = ` scale(${1 - 0.2 * progress})`;
                        }
                    }
                    el.style.transform = `${baseTransform} ${newTransform}`;
                };
                
                applyAnimation(textWrapper, card.animations.text, card.duration, timeInCard);
                if(showMedia) applyAnimation(mediaWrapper, card.animations.media, card.duration, timeInCard);
            }
        };
        const handlers = {
            updateProjectSettings() {
                state.projectSettings.header.text = document.getElementById('st-setting-header-text').value;
                state.projectSettings.header.backgroundColor = document.getElementById('st-setting-header-bg').value;
                state.projectSettings.header.color = document.getElementById('st-setting-header-color').value;
                state.projectSettings.header.fontFamily = document.getElementById('st-setting-header-font').value;
                state.projectSettings.header.fontSize = document.getElementById('st-setting-header-size').value;
                state.projectSettings.header.icon = document.getElementById('st-setting-header-icon').value;
                state.projectSettings.header.logo.size = document.getElementById('st-setting-header-logo-size').value;
                state.projectSettings.project.title = document.getElementById('st-setting-project-title').value;
                state.projectSettings.project.titleFontFamily = document.getElementById('st-setting-project-font').value;
                state.projectSettings.project.titleFontSize = document.getElementById('st-setting-project-size').value;
                state.projectSettings.project.author = document.getElementById('st-setting-project-author').value;
                state.projectSettings.project.views = document.getElementById('st-setting-project-views').value;
                state.projectSettings.project.titleColor = document.getElementById('st-setting-title-color').value;
                state.projectSettings.project.metaColor = document.getElementById('st-setting-meta-color').value;
                state.projectSettings.defaultStyle.color = document.getElementById('st-setting-script-color').value;
                state.projectSettings.defaultStyle.fontFamily = document.getElementById('st-setting-script-font').value;
                state.projectSettings.defaultStyle.fontSize = document.getElementById('st-setting-script-size').value;
                state.projectSettings.defaultStyle.lineHeight = document.getElementById('st-setting-line-height').value;
                state.projectSettings.defaultStyle.letterSpacing = document.getElementById('st-setting-letter-spacing').value;
                state.globalBGM.volume = parseFloat(document.getElementById('st-setting-global-bgm-volume').value);
                if (UI.bgmPlayer) UI.bgmPlayer.volume = state.globalBGM.volume;
                handlers.applyScriptStylesToSelectedCard();
                render.updatePreviewDisplay();
            },
            updateScriptStyleControls() {
                const card = state.scriptCards.find(c => c.id === state.selectedCardId); if (!card) return;
                document.getElementById('st-setting-script-color').value = card.style?.color || state.projectSettings.defaultStyle.color;
                document.getElementById('st-setting-script-font').value = card.style?.fontFamily || state.projectSettings.defaultStyle.fontFamily;
                document.getElementById('st-setting-script-size').value = (card.style?.fontSize || state.projectSettings.defaultStyle.fontSize).replace('px','');
                document.getElementById('st-setting-line-height').value = card.style?.lineHeight || state.projectSettings.defaultStyle.lineHeight;
                document.getElementById('st-setting-letter-spacing').value = (card.style?.letterSpacing || state.projectSettings.defaultStyle.letterSpacing).replace('px','');
            },
            applyScriptStylesToSelectedCard() {
                const card = state.scriptCards.find(c => c.id === state.selectedCardId); if (!card) return;
                card.style.color = document.getElementById('st-setting-script-color').value;
                card.style.fontFamily = document.getElementById('st-setting-script-font').value;
                card.style.fontSize = document.getElementById('st-setting-script-size').value + 'px';
                card.style.lineHeight = document.getElementById('st-setting-line-height').value;
                card.style.letterSpacing = document.getElementById('st-setting-letter-spacing').value + 'px';
                render.updatePreviewDisplay();
            },
            addScriptCard(text = '') {
                const cardId = helpers.generateId('card');
                const cardData = {
                    id: cardId, text, segments: [], animationSequence: [], duration: 0.5, ttsDuration: 0.5, isDurationManual: false,
                    media: { url: null, type: null, fit: 'contain', showOnSegment: 1, persistUntilCardId: null, startTime: 0, endTime: null },
                    style: { ...state.projectSettings.defaultStyle, fontSize: state.projectSettings.defaultStyle.fontSize + 'px', letterSpacing: state.projectSettings.defaultStyle.letterSpacing + 'px', textAlign: state.projectSettings.defaultStyle.textAlign }, // textAlign ì¶”ê°€
                    audioUrl: null, ttsReady: false, ttsVolume: 0.9, 
                    ttsSettings: { speed: 1.0 }, // ê¸°ë³¸ ì†ë„ë¥¼ 1.0ìœ¼ë¡œ ì„¤ì •í•˜ê³ , ë¶ˆí•„ìš”í•œ ê°’ ì œê±°
                    ttsVoice: 'ko-KR-Standard-C', // ê¸°ë³¸ ëª©ì†Œë¦¬ ì„¤ì •
                    sfxUrl: null, sfxVolume: 0.8,
                    layout: { text: { x: 0, y: 0, scale: 1, angle: 0 }, media: { x: 0, y: 0, scale: 1, angle: 0 } },
                    // [ìˆ˜ì •] ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ê¸°ë³¸ê°’ì„ 'ì—†ìŒ(none)'ìœ¼ë¡œ ì„¤ì •
                    animations: {
                        text: { in: { name: 'none', duration: 0.5 }, out: { name: 'none', duration: 0.5 } },
                        media: { in: { name: 'none', duration: 0.5 }, out: { name: 'none', duration: 0.5 } }
                    }
                };
                state.scriptCards.push(cardData);
                const cardEl = render.cardElement(cardData);
                UI.cardContainer.appendChild(cardEl);
                handlers.bindCardEvents(cardEl);
                const editor = cardEl.querySelector('.st-script-editor');
                render.segmentsInEditor(editor, cardData.text);
                if (text.trim()) debouncedTTSRequest(cardId);
                else cardData.ttsReady = true;
                if (!state.selectedCardId) handlers.selectCard(cardId);
                render.updateCardNumbers();
                render.updateCardUI(cardId);
            },
            bindCardEvents(cardEl) {
                const cardId = cardEl.dataset.id;
                const editor = cardEl.querySelector('.st-script-editor');
               cardEl.querySelector('.tts-voice-select').addEventListener('change', (e) => {
    const cardData = state.scriptCards.find(c => c.id === cardId);
    if (cardData) {
        cardData.ttsVoice = e.target.value;
        // ëª©ì†Œë¦¬ë¥¼ ë°”ê¾¸ë©´ ë°”ë¡œ ìƒˆ ìŒì„±ì„ ìƒì„±í•˜ë„ë¡ ìš”ì²­
        debouncedTTSRequest(cardId);
    }
});
                
                editor.addEventListener('input', () => {
                    const parentCardEl = editor.closest('.st-card');
                    if (!parentCardEl) return;
                    const currentCardId = parentCardEl.dataset.id;
                    const currentCardData = state.scriptCards.find(c => c.id === currentCardId);
                    if (!currentCardData) return;
                    currentCardData.text = Array.from(editor.children).map(child => child.textContent).join('\n');
                    render.updatePreviewDisplay();
                    render.updateCardUI(currentCardId);
                    debouncedTTSRequest(currentCardId);
                });

                const cardData = state.scriptCards.find(c => c.id === cardId);

                new Sortable(editor, { 
                    animation: 150, ghostClass: 'sortable-ghost', 
                    onEnd: () => { 
                        cardData.text = Array.from(editor.children).map(child => child.textContent).join('\n'); 
                        render.updatePreviewDisplay(); 
                        debouncedTTSRequest(cardId); 
                    }
                });
                
                cardEl.querySelector(`#${cardId}-file`).addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        if (cardData.media.url && cardData.media.url.startsWith('blob:')) { URL.revokeObjectURL(cardData.media.url); }
                        const url = URL.createObjectURL(file);
                        if (file.type.startsWith('video/')) { modals.openVideoTrimmer(url, cardId); } 
                        else { cardData.media.url = url; cardData.media.type = 'image'; render.updateCardUI(cardId); if (state.selectedCardId === cardId) render.updatePreviewDisplay(); }
                    }
                });

                cardEl.querySelector('.media-timing-select').addEventListener('change', e => cardData.media.showOnSegment = parseInt(e.target.value, 10));
                cardEl.querySelector('.media-persist-select').addEventListener('change', e => cardData.media.persistUntilCardId = e.target.value || null);
                cardEl.querySelectorAll(`input[name="media-fit-${cardId}"]`).forEach(radio => { radio.addEventListener('change', e => { cardData.media.fit = e.target.value; if(state.selectedCardId === cardId) render.updatePreviewDisplay(); }); });
                cardEl.querySelector('.st-play-clip-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    playback.stop(); // ë‹¤ë¥¸ ì¬ìƒì€ ëª¨ë‘ ë©ˆì¶¤

                    // [ìˆ˜ì •] ê°€ì¥ ê°„ë‹¨í•œ ì§ì ‘ ì¬ìƒ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
                    if (cardData.ttsReady && cardData.audioUrl) {
                        UI.ttsPlayer.src = cardData.audioUrl;
                        UI.ttsPlayer.volume = cardData.ttsVolume;
                        UI.ttsPlayer.playbackRate = cardData.ttsSettings.speed;
                        UI.ttsPlayer.play().catch(err => console.error("ë¯¸ë¦¬ë“£ê¸° TTS ì¬ìƒ ì˜¤ë¥˜:", err));
                    }
                    if (cardData.sfxUrl) {
                        UI.sfxPlayer.src = cardData.sfxUrl;
                        UI.sfxPlayer.volume = cardData.sfxVolume;
                        UI.sfxPlayer.play().catch(err => console.error("ë¯¸ë¦¬ë“£ê¸° SFX ì¬ìƒ ì˜¤ë¥˜:", err));
                    }
                });                
                cardEl.querySelector('.tts-speed-slider').addEventListener('input', e => {
    const cardData = state.scriptCards.find(c => c.id === cardId);
    if (cardData) {
        cardData.ttsSettings.speed = parseFloat(e.target.value);
        cardEl.querySelector('.tts-speed-input').value = cardData.ttsSettings.speed.toFixed(1);
    }
});

cardEl.querySelector('.tts-speed-slider').addEventListener('change', () => {
    debouncedTTSRequest(cardId);
});

cardEl.querySelector('.tts-speed-input').addEventListener('change', e => {
    const cardData = state.scriptCards.find(c => c.id === cardId);
    const speed = parseFloat(e.target.value);
    if (cardData && !isNaN(speed)) {
        cardData.ttsSettings.speed = speed;
        cardEl.querySelector('.tts-speed-slider').value = speed;
        debouncedTTSRequest(cardId);
    }
});

                cardEl.querySelector('.st-sfx-select').addEventListener('change', (e) => {
                    const url = e.target.value;
                    if (url === 'upload-my-own') { state.sfxUploadTargetCardId = cardId; UI.sfxFileInput.value = null; UI.sfxFileInput.click(); e.target.value = cardData.sfxUrl || ''; return; }
                    cardData.sfxUrl = url || null;
                    if (url) { UI.sfxPlayer.src = url; UI.sfxPlayer.volume = cardData.sfxVolume; UI.sfxPlayer.play(); const sfxItem = state.sfxList.find(item => item.url === url); if (sfxItem) { state.recentlyUsedSfx = [sfxItem, ...state.recentlyUsedSfx.filter(item => item.url !== url)].slice(0, 5); render.allSfxSelects(); } }
                });
                cardEl.querySelectorAll('.st-volume-slider').forEach(slider => {
                    slider.addEventListener('input', e => {
                        const targetCard = state.scriptCards.find(c => c.id === e.target.dataset.targetId);
                        const volumeType = e.target.dataset.type === 'tts-volume' ? 'ttsVolume' : 'sfxVolume';
                        const newValue = parseFloat(e.target.value);
                        if(targetCard) targetCard[volumeType] = newValue;
                        const numberInput = cardEl.querySelector(`.value-input[data-type="${e.target.dataset.type}"]`);
                        if(numberInput) numberInput.value = Math.round(newValue * 100);
                    });
                });
                cardEl.querySelectorAll('.value-input').forEach(input => {
                    input.addEventListener('input', e => {
                        const targetCard = state.scriptCards.find(c => c.id === e.target.dataset.targetId);
                        const volumeType = e.target.dataset.type === 'tts-volume' ? 'ttsVolume' : 'sfxVolume';
                        const newValue = parseFloat(e.target.value) / 100;
                        if(targetCard && !isNaN(newValue)) targetCard[volumeType] = newValue;
                        const slider = cardEl.querySelector(`.st-volume-slider[data-type="${e.target.dataset.type}"]`);
                        if (slider && !isNaN(newValue)) slider.value = newValue;
                    });
                });
                cardEl.querySelector('.st-duration-label').addEventListener('click', () => { cardData.isDurationManual = !cardData.isDurationManual; if (!cardData.isDurationManual) { cardData.duration = cardData.ttsDuration; } render.updateCardUI(cardId); handlers.updateTotalDuration(); });
                cardEl.querySelector('.st-duration-input').addEventListener('input', (e) => { if (cardData.isDurationManual) { cardData.duration = parseFloat(e.target.value) || 0.5; handlers.updateTotalDuration(); } });
                cardEl.querySelector('.st-btn-delete-card').addEventListener('click', (e) => { e.stopPropagation(); handlers.deleteCard(cardId); });
                cardEl.addEventListener('click', () => handlers.selectCard(cardId));
            },
            deleteCard(cardId) {
                const cardIndex = state.scriptCards.findIndex(c => c.id === cardId); if (cardIndex === -1) return;
                const cardData = state.scriptCards[cardIndex];
                if (cardData.media.url && cardData.media.url.startsWith('blob:')) { URL.revokeObjectURL(cardData.media.url); }
                state.scriptCards.splice(cardIndex, 1);
                document.querySelector(`.st-card[data-id="${cardId}"]`).remove();
                if (state.selectedCardId === cardId) {
                    state.selectedCardId = null;
                    if (state.scriptCards.length > 0) { const nextIndex = Math.max(0, cardIndex - 1); if (state.scriptCards[nextIndex]) handlers.selectCard(state.scriptCards[nextIndex].id); } 
                    else { render.updatePreviewDisplay(); }
                }
                handlers.updateTotalDuration(); render.updateCardNumbers(); interaction.deactivateAllInteractive();
            },
            updateTotalDuration() { const total = state.scriptCards.reduce((sum, card) => sum + (card.duration || 0.5), 0); if (UI.timelineSlider) UI.timelineSlider.max = total; },
            selectCard(cardId, fromPlayback = false) {
                if (state.isPlaying && !fromPlayback) playback.stop();
                if (state.selectedCardId === cardId && !fromPlayback) return;
                state.selectedCardId = cardId;
                interaction.deactivateAllInteractive();
                document.querySelectorAll('.st-card').forEach(c => c.classList.remove('active'));
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (cardEl) {
                    cardEl.classList.add('active');
                    if (!fromPlayback) cardEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    handlers.updateScriptStyleControls();
                }
                render.updatePreviewDisplay();
            },
        };
        const interaction = {
            deactivateAllInteractive() {
                state.activeInteractiveElement = null; render.showPanel('global');
                document.querySelectorAll('.interactive-target.interactive-active').forEach(el => el.classList.remove('interactive-active'));
            },
            activateInteractive(target) {
                if (state.activeInteractiveElement === target) return;
                interaction.deactivateAllInteractive();
                state.activeInteractiveElement = target; 
                target.classList.add('interactive-active');
                render.animationControls(target);
            },
            sequence: {
                showMenu: (x, y) => {
                    const { cardId } = state.currentSelectionContext;
                    const cardData = state.scriptCards.find(c => c.id === cardId); if(!cardData) return;
                    const sequence = cardData.animationSequence || []; let menuItems = '';
                    for(let i=0; i <= sequence.length; i++) { menuItems += `<li data-action="set" data-index="${i}">${i + 1}ë²ˆì§¸ë¡œ ì¬ìƒ</li>`; }
                    menuItems += '<hr><li data-action="clear">ìˆœì„œ ì´ˆê¸°í™”</li>';
                    UI.sequenceMenu.innerHTML = menuItems; UI.sequenceMenu.style.left = `${x + 10}px`; UI.sequenceMenu.style.top = `${y}px`; UI.sequenceMenu.style.display = 'block';
                },
                hideMenu: () => { UI.sequenceMenu.style.display = 'none'; state.currentSelectionContext = null; },
                handleMenuClick: (e) => {
                    if (e.target.tagName !== 'LI' || !state.currentSelectionContext) return;
                    const { cardId, text } = state.currentSelectionContext;
                    const cardData = state.scriptCards.find(c => c.id === cardId); if (!cardData) return;
                    const action = e.target.dataset.action;
                    if (action === 'set') {
                        const index = parseInt(e.target.dataset.index, 10);
                        cardData.animationSequence = cardData.animationSequence.filter(seqText => seqText !== text);
                        cardData.animationSequence.splice(index, 0, text);
                    } else if (action === 'clear') { cardData.animationSequence = []; }
                    debouncedTTSRequest(cardId); interaction.sequence.hideMenu();
                },
                onSelectionChange: () => {
                    const selection = window.getSelection(); if (!selection || selection.isCollapsed) { interaction.sequence.hideMenu(); return; }
                    const editor = selection.anchorNode?.parentElement?.closest('.st-script-editor');
                    if(editor) {
                        const range = selection.getRangeAt(0);
                        const segmentEl = range.startContainer.parentElement.closest('.script-segment');
                        if (!segmentEl || !segmentEl.textContent.trim()) { interaction.sequence.hideMenu(); return; }
                        const cardEl = editor.closest('.st-card');
                        state.currentSelectionContext = { cardId: cardEl.dataset.id, text: selection.toString().trim() };
                        if(state.currentSelectionContext.text) { const rect = range.getBoundingClientRect(); interaction.sequence.showMenu(rect.right, rect.top); }
                    } else { interaction.sequence.hideMenu(); }
                }
            },
            initialize() {
        // [ìƒˆ ì½”ë“œ ì¶”ê°€] ê°€ì´ë“œ ë¼ì¸ DOM ìš”ì†Œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        const verticalGuide = document.getElementById('st-guide-vertical');
        const horizontalGuide = document.getElementById('st-guide-horizontal');
        const previewPanel = document.getElementById('st-preview-panel');

        interact('.interactive-target').on('tap', (event) => { interaction.activateInteractive(event.currentTarget); event.preventDefault(); });
        
        interact('.interactive-target')
            .draggable({
                listeners: {
                    start(event) {
                        // ë“œë˜ê·¸ ì‹œì‘ ì‹œ bodyì— í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì—¬ ë§ˆìš°ìŠ¤ ì»¤ì„œ ìŠ¤íƒ€ì¼ ë“±ì„ ê´€ë¦¬
                        document.body.classList.add('interaction-active');
                    },
                    move(event) {
                        const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                        if (!card) return;

                        const layoutKey = event.target.dataset.layoutKey;
                        const layout = card.layout[layoutKey];
                        
                        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                        layout.x = (layout.x || 0) + event.dx;
                        layout.y = (layout.y || 0) + event.dy;
                        
                        // [ìƒˆ ì½”ë“œ ì¶”ê°€] ìŠ¤ëƒ… ê°€ì´ë“œ ë¡œì§
                        const snapThreshold = 5;
                        const panelRect = previewPanel.getBoundingClientRect();
                        const targetRect = event.target.getBoundingClientRect();
                        
                        const panelCenterX = panelRect.left + panelRect.width / 2;
                        const panelCenterY = panelRect.top + panelRect.height / 2;
                        
                        const targetCenterX = targetRect.left + targetRect.width / 2;
                        const targetCenterY = targetRect.top + targetRect.height / 2;

                        // ìˆ˜ì§ ê°€ì´ë“œ (Xì¶• ì¤‘ì•™)
                        if (Math.abs(targetCenterX - panelCenterX) < snapThreshold) {
                            layout.x -= (targetCenterX - panelCenterX); // í”½ì…€ ë‹¨ìœ„ë¡œ ë³´ì •
                            verticalGuide.style.left = `${panelCenterX}px`;
                            verticalGuide.style.display = 'block';
                        } else {
                            verticalGuide.style.display = 'none';
                        }

                        // ìˆ˜í‰ ê°€ì´ë“œ (Yì¶• ì¤‘ì•™)
                        if (Math.abs(targetCenterY - panelCenterY) < snapThreshold) {
                            layout.y -= (targetCenterY - panelCenterY); // í”½ì…€ ë‹¨ìœ„ë¡œ ë³´ì •
                            horizontalGuide.style.top = `${panelCenterY}px`;
                            horizontalGuide.style.display = 'block';
                        } else {
                            horizontalGuide.style.display = 'none';
                        }
                        
                        render.applyTransform(event.target, layout);
                    },
                    end(event) {
                        // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ê°€ì´ë“œ ìˆ¨ê¸°ê¸° ë° í´ë˜ìŠ¤ ì œê±°
                        verticalGuide.style.display = 'none';
                        horizontalGuide.style.display = 'none';
                        document.body.classList.remove('interaction-active');
                    }
                }
            })
            .gesturable({
                listeners: {
                    move (event) {
                        const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                        if (!card) return;

                        const layoutKey = event.target.dataset.layoutKey;
                        const layout = card.layout[layoutKey];
                        
                        layout.angle = (layout.angle || 0) + event.da;
                        layout.scale = (layout.scale || 1) * (1 + event.ds);
                        
                        render.applyTransform(event.target, layout);
                    }
                }
            });

        UI.previewContent.addEventListener('click', (e) => { if (!e.target.closest('.interactive-target')) interaction.deactivateAllInteractive(); });
        document.addEventListener('selectionchange', helpers.debounce(interaction.sequence.onSelectionChange, 200));
        document.addEventListener('mousedown', (e) => { if (!UI.sequenceMenu.contains(e.target) && !e.target.closest('.st-script-editor')) interaction.sequence.hideMenu(); });
        UI.sequenceMenu.addEventListener('click', interaction.sequence.handleMenuClick);
    }
    // â–²â–²â–²â–²â–² ì—¬ê¸°ê¹Œì§€ êµì²´ ì™„ë£Œ! â–²â–²â–²â–²â–²
};
        const modals = {
            openBgmEditor(url, onConfirm) {
                state.bgmEditorContext = { onConfirm };
                UI.bgmModal.classList.add('visible');
                const loadingEl = UI.bgmModal.querySelector('.waveform-loading');
                loadingEl.style.display = 'block';
                if (state.bgmWavesurfer) state.bgmWavesurfer.destroy();
                state.bgmWavesurfer = WaveSurfer.create({ container: '#st-waveform-container-bgm', waveColor: '#ddd', progressColor: '#e82c43', cursorColor: '#fff', barWidth: 2, barRadius: 3, plugins: [ WaveSurfer.regions.create({ dragSelection: { slop: 5 } }) ] });
                state.bgmWavesurfer.load(url);
                state.bgmWavesurfer.on('ready', () => {
                    loadingEl.style.display = 'none'; state.bgmWavesurfer.clearRegions();
                    const duration = state.bgmWavesurfer.getDuration();
                    const initialEnd = Math.min(60, duration);
                    state.activeBgmRegion = state.bgmWavesurfer.addRegion({ start: 0, end: initialEnd, color: 'rgba(232, 44, 67, 0.3)', drag: true, resize: true });
                    document.getElementById('st-bgm-time-display').textContent = `${state.activeBgmRegion.start.toFixed(2)}s - ${state.activeBgmRegion.end.toFixed(2)}s`;
                });
                state.bgmWavesurfer.on('region-updated', (region) => { state.activeBgmRegion = region; document.getElementById('st-bgm-time-display').textContent = `${region.start.toFixed(2)}s - ${region.end.toFixed(2)}s`; });
                state.bgmWavesurfer.on('error', (e) => { console.error("Wavesurfer error:", e); alert("BGM íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."); modals.closeBgmEditor(); })
            },
            closeBgmEditor: () => { UI.bgmModal.classList.remove('visible'); if (state.bgmWavesurfer) { state.bgmWavesurfer.destroy(); state.bgmWavesurfer = null; } },
            openVideoTrimmer(url, cardId) {
                state.videoTrimmerContext = { cardId, url, activeHandle: 'end' };
                UI.videoTrimModal.classList.add('visible');
                const loadingEl = UI.videoTrimModal.querySelector('.waveform-loading');
                const previewVideo = UI.videoTrimModal.querySelector('video');
                previewVideo.src = url;
                loadingEl.style.display = 'block';
                if (state.videoWavesurfer) state.videoWavesurfer.destroy();
                state.videoWavesurfer = WaveSurfer.create({ container: '#st-waveform-container-video', waveColor: '#ddd', progressColor: '#e82c43', cursorColor: '#fff', barWidth: 2, barRadius: 3, backend: 'MediaElement', media: previewVideo, plugins: [ WaveSurfer.regions.create({ dragSelection: { slop: 5 } }) ] });
                const onReady = () => {
                    loadingEl.style.display = 'none';
                    state.videoWavesurfer.clearRegions();
                    const duration = state.videoWavesurfer.getDuration();
                    if (!isFinite(duration) || duration === 0) { setTimeout(onReady, 100); return; }
                    const initialEnd = Math.min(10, duration);
                    state.activeVideoRegion = state.videoWavesurfer.addRegion({ start: 0, end: initialEnd, color: 'rgba(232, 44, 67, 0.3)', drag: true, resize: true });
                    document.getElementById('st-video-time-display').textContent = `${state.activeVideoRegion.start.toFixed(2)}s - ${state.activeVideoRegion.end.toFixed(2)}s`;
                    state.videoWavesurfer.on('region-in', () => { state.videoTrimmerContext.activeHandle = 'start'; });
                    state.videoWavesurfer.on('region-out', () => { state.videoTrimmerContext.activeHandle = 'end'; });
                };
                state.videoWavesurfer.on('ready', onReady);
                state.videoWavesurfer.on('region-updated', (region) => { state.activeVideoRegion = region; document.getElementById('st-video-time-display').textContent = `${region.start.toFixed(2)}s - ${region.end.toFixed(2)}s`; if(!previewVideo.paused) previewVideo.pause(); previewVideo.currentTime = region.start; });
                state.videoWavesurfer.on('error', (e) => { console.error("Wavesurfer error:", e); alert("ë¹„ë””ì˜¤ íŒŒì¼ì„ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ íŒŒì¼ì„ ì‹œë„í•´ë³´ì„¸ìš”."); modals.closeVideoTrimmer(); })
            },
            closeVideoTrimmer: () => {
                UI.videoTrimModal.classList.remove('visible');
                const previewVideo = UI.videoTrimModal.querySelector('video');
                if (state.videoWavesurfer) { state.videoWavesurfer.destroy(); state.videoWavesurfer = null; }
                if (previewVideo) { previewVideo.pause(); previewVideo.removeAttribute('src'); previewVideo.load(); }
                if (state.videoTrimmerContext.url && state.videoTrimmerContext.url.startsWith('blob:')) { URL.revokeObjectURL(state.videoTrimmerContext.url); }
                state.videoTrimmerContext = { cardId: null, url: null, activeHandle: 'end' };
            },
            adjustVideoRegionByFrames(frames) {
                if (!state.activeVideoRegion || !state.videoWavesurfer) return;
                const region = state.activeVideoRegion;
                const totalDuration = state.videoWavesurfer.getDuration();
                const timeChange = frames / 30.0;
                let { start, end } = region;
                if (state.videoTrimmerContext.activeHandle === 'start') { start = Math.max(0, start + timeChange); if (start >= end) start = end - 0.01; } 
                else { end = Math.min(totalDuration, end + timeChange); if (end <= start) end = start + 0.01; }
                region.update({ start, end });
            },
            initialize() {
                document.getElementById('st-btn-bgm-play-pause').addEventListener('click', () => state.bgmWavesurfer?.playPause());
                document.getElementById('st-btn-bgm-play-region').addEventListener('click', () => state.activeBgmRegion?.play());
                document.getElementById('st-btn-bgm-confirm').addEventListener('click', () => { if (state.bgmEditorContext.onConfirm && state.activeBgmRegion) { state.bgmEditorContext.onConfirm({ startTime: state.activeBgmRegion.start, endTime: state.activeBgmRegion.end }); } modals.closeBgmEditor(); });
                document.getElementById('st-btn-bgm-cancel').addEventListener('click', modals.closeBgmEditor);
                document.getElementById('st-btn-video-play-region').addEventListener('click', () => {
                    if (state.activeVideoRegion) {
                        const previewVideo = UI.videoTrimModal.querySelector('video');
                        previewVideo.currentTime = state.activeVideoRegion.start;
                        previewVideo.play();
                        const playbackDuration = (state.activeVideoRegion.end - state.activeVideoRegion.start) * 1000;
                        setTimeout(() => { if (!previewVideo.paused) previewVideo.pause(); }, playbackDuration);
                    }
                });
                document.getElementById('st-btn-video-confirm').addEventListener('click', () => {
                    const { cardId, url } = state.videoTrimmerContext;
                    const cardData = state.scriptCards.find(c => c.id === cardId);
                    if (cardData && state.activeVideoRegion) { cardData.media.url = url; cardData.media.type = 'video'; cardData.media.startTime = state.activeVideoRegion.start; cardData.media.endTime = state.activeVideoRegion.end; render.updateCardUI(cardId); if (state.selectedCardId === cardId) render.updatePreviewDisplay(); }
                    modals.closeVideoTrimmer();
                });
                document.getElementById('st-btn-video-cancel').addEventListener('click', modals.closeVideoTrimmer);
                document.getElementById('st-btn-video-frame-prev').addEventListener('click', () => modals.adjustVideoRegionByFrames(-1));
                document.getElementById('st-btn-video-frame-next').addEventListener('click', () => modals.adjustVideoRegionByFrames(1));
            }
        };
        async function initialize() {
            try { const response = await fetch('https://sunsaktool-final.netlify.app/sfx-list.json'); if (!response.ok) throw new Error('Network response was not ok'); state.sfxList = await response.json(); } catch (e) { console.error("íš¨ê³¼ìŒ ëª©ë¡(sfx-list.json)ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", e); state.sfxList = [{ name: "íš¨ê³¼ìŒ ëª©ë¡ ë¡œë”© ì‹¤íŒ¨", url: "" }]; }
            render.globalControls();
            UI.addCardBtn.addEventListener('click', () => handlers.addScriptCard(''));
            UI.newProjectBtn.addEventListener('click', () => { if(confirm('ì •ë§ë¡œ ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ì‘ì—… ë‚´ìš©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.')) { location.reload(); } });
            UI.playAllBtn.addEventListener('click', playback.togglePlay);
            UI.globalSettingsPanel.addEventListener('input', (e) => {
                const target = e.target;
                if (target.id.startsWith('st-setting-')) {
                    if (target.type === 'range') { const numberInput = document.querySelector(`.value-input[data-target="${target.id}"]`); if (numberInput) { numberInput.value = target.id.includes('volume') ? Math.round(target.value * 100) : target.value; } }
                    handlers.updateProjectSettings();
                } else if (target.classList.contains('value-input')) { const slider = document.getElementById(target.dataset.target); if (slider) { slider.value = slider.id.includes('volume') ? parseFloat(target.value) / 100 : target.value; handlers.updateProjectSettings(); } }
            });
            UI.addGptsBtn.addEventListener('click', () => UI.gptsModal.classList.add('visible'));
            const closeGptsModal = () => { UI.gptsModal.classList.remove('visible'); UI.gptsTextarea.value = ''; };
            UI.gptsCancelBtn.addEventListener('click', closeGptsModal);
            UI.gptsModal.addEventListener('click', (e) => { if (e.target === UI.gptsModal) closeGptsModal(); });
            UI.gptsConfirmBtn.addEventListener('click', () => { const lines = UI.gptsTextarea.value.trim().split(/\n\s*\n/).filter(line => line.trim() !== ''); lines.forEach(line => handlers.addScriptCard(line.trim())); closeGptsModal(); if(lines.length > 0 && state.scriptCards.length > 0) handlers.selectCard(state.scriptCards[state.scriptCards.length - lines.length].id); });
            document.getElementById('st-setting-global-bgm').addEventListener('change', (e) => {
                const url = e.target.value;
                if (url) { modals.openBgmEditor(url, ({ startTime, endTime }) => { state.globalBGM = { ...state.globalBGM, url, startTime, endTime }; document.getElementById('st-setting-global-bgm').value = url; if (state.isPlaying) playback.playBGM(); }); } 
                else { state.globalBGM.url = null; if (state.isPlaying) UI.bgmPlayer.pause(); }
            });
            document.getElementById('st-btn-upload-bgm').addEventListener('click', () => UI.bgmFileInput.click());
            document.getElementById('st-btn-header-logo').addEventListener('click', () => document.getElementById('st-header-logo-file').click());
            document.getElementById('st-header-logo-file').addEventListener('change', (e) => { if (e.target.files && e.target.files[0]) { const reader = new FileReader(); reader.onload = (event) => { state.projectSettings.header.logo.url = event.target.result; render.updatePreviewDisplay(); }; reader.readAsDataURL(e.target.files[0]); } });
            UI.sfxFileInput.addEventListener('change', (e) => {
                if (!e.target.files || e.target.files.length === 0) return;
                const file = e.target.files[0]; const url = URL.createObjectURL(file); const newSfx = { name: file.name, url };
                if (!state.sfxList.find(item => item.url === url)) state.sfxList.push(newSfx);
                const cardToUpdate = state.scriptCards.find(c => c.id === state.sfxUploadTargetCardId);
                if (cardToUpdate) cardToUpdate.sfxUrl = url;
                state.recentlyUsedSfx = [newSfx, ...state.recentlyUsedSfx.filter(item => item.url !== url)].slice(0, 5);
                render.allSfxSelects();
                const cardEl = document.querySelector(`.st-card[data-id="${state.sfxUploadTargetCardId}"]`);
                if(cardEl) cardEl.querySelector('.st-sfx-select').value = url;
            });
            UI.bgmFileInput.addEventListener('change', (e) => { if (e.target.files && e.target.files[0]) { const file = e.target.files[0]; const url = URL.createObjectURL(file); modals.openBgmEditor(url, ({ startTime, endTime }) => { state.globalBGM = { ...state.globalBGM, url, startTime, endTime }; if (state.isPlaying) playback.playBGM(); }); } });
            document.addEventListener('paste', (event) => {
                if (!state.selectedCardId) return;
                const card = state.scriptCards.find(c => c.id === state.selectedCardId); if (!card) return;
                const items = (event.clipboardData || window.clipboardData).items;
                for (const item of items) {
                    if (item.type.indexOf('image') === 0) {
                        event.preventDefault(); const file = item.getAsFile(); 
                        if (card.media.url && card.media.url.startsWith('blob:')) { URL.revokeObjectURL(card.media.url); }
                        card.media.url = URL.createObjectURL(file);
                        card.media.type = 'image'; render.updateCardUI(card.id); render.updatePreviewDisplay(); break;
                    }
                }
            });
            interaction.initialize();
            modals.initialize();
            new Sortable(UI.cardContainer, { animation: 150, handle: '.st-card-drag-handle', onEnd: function(evt) { const { oldIndex, newIndex } = evt; const [movedItem] = state.scriptCards.splice(oldIndex, 1); state.scriptCards.splice(newIndex, 0, movedItem); render.updateCardNumbers(); } });
            UI.exportBtn.addEventListener('click', () => exporter.startExport());
            document.getElementById('st-text-align-group').addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON') {
        const alignValue = e.target.dataset.align;
        if(state.selectedCardId) {
            const card = state.scriptCards.find(c => c.id === state.selectedCardId);
            if (card) {
                card.style.textAlign = alignValue;
                render.updatePreviewDisplay();
            }
        } else { // ì„ íƒëœ ì¹´ë“œê°€ ì—†ì„ ê²½ìš° ê¸°ë³¸ê°’ ë³€ê²½
            state.projectSettings.defaultStyle.textAlign = alignValue;
        }
    }
});

handlers.addScriptCard('ìˆœì‚­íˆ´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!\ní…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•´ì„œ ì¬ìƒ ìˆœì„œë¥¼ ì •í•´ë³´ì„¸ìš”.');
}

        
const exporter = {
    statusCheckInterval: null,
    
    waitForMediaAndVerify(element) {
        const mediaPromises = [];
        const images = Array.from(element.querySelectorAll('img'));
        images.forEach(img => {
            if (!img.src) return;
            if (img.complete && img.naturalWidth !== 0) return;
            mediaPromises.push(new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${img.src}`));
            }));
        });
        const videos = Array.from(element.querySelectorAll('video'));
        videos.forEach(video => {
            if (video.readyState < 4 && video.src) {
                mediaPromises.push(new Promise((resolve, reject) => {
                    video.oncanplaythrough = resolve;
                    video.onerror = () => reject(new Error(`ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ${video.src}`));
                }));
            }
        });
        return Promise.all(mediaPromises);
    },

    async checkStatus(jobId) {
        try {
            const response = await fetch(`${SERVICE_URL}/render-status/${jobId}`);
            if (!response.ok) {
                if (response.status === 404) return;
                throw new Error(`ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: ${response.status}`);
            }
            const data = await response.json();
            UI.progressSubText.textContent = data.message || 'ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ìˆìŠµë‹ˆë‹¤...';
            if (data.progress) UI.progressBarInner.style.width = `${data.progress}%`;
            if (data.status === 'completed') {
                clearInterval(this.statusCheckInterval);
                UI.progressText.textContent = 'ì˜ìƒ ì œì‘ ì™„ë£Œ!';
                UI.progressBarInner.style.width = '100%';
                UI.progressSubText.textContent = 'ë‹¤ìš´ë¡œë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...';
                try {
                    const res = await fetch(data.videoUrl);
                    const blob = await res.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `${state.projectSettings.project.title || 'sunsak-video'}.mp4`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } catch (downloadError) {
                    console.error("ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:", downloadError);
                    UI.progressSubText.innerHTML = `ìë™ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨! <a href="${data.videoUrl}" target="_blank" download>ì—¬ê¸°ì„œ ì§ì ‘ ë‹¤ìš´ë¡œë“œ</a>`;
                    alert("ìë™ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì•„ë˜ ë§í¬ë¥¼ ì§ì ‘ í´ë¦­í•´ì£¼ì„¸ìš”.");
                }
                setTimeout(() => {
                    UI.progressOverlay.style.display = 'none';
                    UI.exportBtn.disabled = false;
                }, 3000);
            } else if (data.status === 'failed') {
                clearInterval(this.statusCheckInterval);
                alert(`ì˜ìƒ ì œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì˜¤ë¥˜: ${data.message}`);
                UI.progressOverlay.style.display = 'none';
                UI.exportBtn.disabled = false;
            }
        } catch (error) {
            console.error(error);
        }
    },

    async startExport() {
        if (state.scriptCards.length === 0) return alert('ì¶œë ¥í•  ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤.');
        if (this.statusCheckInterval) clearInterval(this.statusCheckInterval);

        playback.stop();
        UI.exportBtn.disabled = true;
        UI.progressOverlay.style.display = 'flex';
        UI.progressText.textContent = 'ë Œë”ë§ ë°ì´í„° ìƒì„± ì¤‘...';
        UI.progressBarInner.style.width = '2%';

        const totalDuration = state.scriptCards.reduce((sum, c) => sum + c.duration, 0);
        const fps = 30;
        const totalFrames = Math.floor(totalDuration * fps);
        const frameData = [];

        for (const card of state.scriptCards) {
            const cardFrames = Math.floor(card.duration * fps);
            for (let i = 0; i < cardFrames; i++) {
                frameData.push({ card, timeInCard: i / fps });
            }
        }

        const previewPanel = document.getElementById('st-preview-panel');
        const frameImages = [];
        
        const resourceCache = new Map();
        const fetchWithSmartCache = async (url) => {
            if (resourceCache.has(url)) return resourceCache.get(url);
            const toDataURL = (blob) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
            try {
                let dataUrl;
                if (url.startsWith('data:')) {
                    if (!url.startsWith('data:image/') && !url.startsWith('data:font/')) throw new Error(`Invalid data URL MIME type: ${url.substring(0, 30)}...`);
                    dataUrl = url;
                } else if (url.startsWith('blob:')) {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    dataUrl = await toDataURL(blob);
                } else {
                    const proxyUrl = `${SERVICE_URL}/api/proxy?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);
                    if (!response.ok) throw new Error(`Proxy Error: Status ${response.status} for ${url}`);
                    const contentType = response.headers.get('Content-Type');
                    if (!contentType || (!contentType.startsWith('image/') && !contentType.startsWith('font/'))) throw new Error(`Invalid content-type: ${contentType} for ${url}`);
                    const blob = await response.blob();
                    dataUrl = await toDataURL(blob);
                }
                resourceCache.set(url, dataUrl);
                return dataUrl;
            } catch (error) {
                console.error(`Failed to fetch resource: ${url}`, error);
                throw error;
            }
        };
        
        UI.progressSubText.textContent = 'í”„ë ˆì„ ìº¡ì²˜ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤...';

        for (let i = 0; i < totalFrames; i++) {
            const { card, timeInCard } = frameData[i];
            
            playback.updatePreviewForFrame(card, timeInCard);

            try {
                await this.waitForMediaAndVerify(previewPanel);
                
                const dataUrl = await htmlToImage.toPng(previewPanel, {
                    width: 1080, height: 1920, style: { margin: 0 }, pixelRatio: 1, fetchRequest: fetchWithSmartCache, cache: 'no-store'
                });
                frameImages.push(dataUrl);

                const progress = 2 + Math.floor((i / totalFrames) * 8); 
                UI.progressSubText.textContent = `í”„ë ˆì„ ìº¡ì²˜ ì¤‘... (${i + 1}/${totalFrames})`;
                UI.progressBarInner.style.width = `${progress}%`;
            } catch (captureError) {
                console.error("í”„ë ˆì„ ìº¡ì²˜ ì˜¤ë¥˜ ì›ë³¸:", captureError);
                let detailedMessage = 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                if (captureError instanceof Error) detailedMessage = captureError.message;
                else if (captureError.target && captureError.target.src) detailedMessage = `ì•„ë˜ ë¦¬ì†ŒìŠ¤ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. URLì´ ìœ íš¨í•œì§€, í˜¹ì€ ì‚­ì œëœ ë¦¬ì†ŒìŠ¤ê°€ ì•„ë‹Œì§€ í™•ì¸í•´ì£¼ì„¸ìš”:\n\n${captureError.target.src}`;
                alert(`í”„ë ˆì„ ìº¡ì²˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n[ì˜¤ë¥˜ ì›ì¸]\n${detailedMessage}`);
                UI.progressOverlay.style.display = 'none';
                UI.exportBtn.disabled = false;
                return;
            }
        }
            
        const projectData = {
            frameImages: frameImages,
            audioTracks: state.scriptCards.map((card, index) => ({
                startTime: state.scriptCards.slice(0, index).reduce((acc, c) => acc + c.duration, 0),
                duration: card.duration,
                tts: card.audioUrl ? { url: card.audioUrl, volume: card.ttsVolume } : null,
                sfx: card.sfxUrl ? { url: card.sfxUrl, volume: card.sfxVolume } : null,
            })),
            globalBGM: state.globalBGM,
            projectSettings: state.projectSettings 
        };

        try {
            UI.progressText.textContent = 'ì„œë²„ì— ì‘ì—… ìš”ì²­ ì¤‘...';
            UI.progressBarInner.style.width = `15%`;
            const response = await fetch(`${SERVICE_URL}/render-video`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(projectData)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'ì„œë²„ ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' }));
                throw new Error(`ì„œë²„ ì˜¤ë¥˜ (${response.status}): ${errorData.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'}`);
            }
            const result = await response.json();
            if (result.success && result.jobId) {
                UI.progressText.textContent = 'ì˜ìƒ ì œì‘ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!';
                this.statusCheckInterval = setInterval(() => this.checkStatus(result.jobId), 5000);
            } else {
                throw new Error('ì„œë²„ì—ì„œ ìœ íš¨í•œ ì‘ì—… IDë¥¼ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error("ì˜ìƒ ìƒì„± ìš”ì²­ ì˜¤ë¥˜:", error);
            alert(`ì˜ìƒ ìƒì„± ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n${error.message}`);
            UI.progressOverlay.style.display = 'none';
            UI.exportBtn.disabled = false;
        }
    }
};
        document.addEventListener('DOMContentLoaded', initialize);
    })();
    </script>
</body>
</html>
