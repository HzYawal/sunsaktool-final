<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>SunsakTool (순삭툴)</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=IBM+Plex+Sans+KR:wght@400;700&family=Gowun+Dodum&family=Gowun+Batang&family=Nanum+Myeongjo:wght@400;700;800&family=Do+Hyeon&family=Black+Han+Sans&family=Gaegu:wght@400;700&family=Hi+Melody&family=Noto+Serif+KR:wght@400;700;900&family=Dokdo&display=swap');
        @font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff') format('woff'); font-weight: 400; }
        @font-face { font-family: 'Spoqa Han Sans Neo'; src: url('https://cdn.jsdelivr.net/gh/spoqa/spoqa-han-sans@latest/Subset/SpoqaHanSansNeo/SpoqaHanSansNeo-Regular.woff2') format('woff2'); font-weight: 400; }
        @font-face { font-family: 'GmarketSans'; src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff'); }
        :root { --st-accent-color: #e82c43; --st-bg-color: #1e1e1e; --st-panel-color: #2a2a2a; --st-border-color: #383838; --st-text-color: #e0e0e0; --st-subtext-color: #aaa; --st-interact-color: #4a90e2;}
        * { box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--st-bg-color); color: var(--st-text-color); display: flex; height: 100vh; margin: 0; overflow: hidden; -webkit-font-smoothing: antialiased; }
        body.interaction-active { user-select: none; -webkit-user-select: none; }
        .st-panel { height: 100vh; display: flex; flex-direction: column; }
        .st-sidebar { width: 280px; background-color: var(--st-panel-color); padding: 20px; border-right: 1px solid var(--st-border-color); overflow-y: auto;}
        .st-main-container { flex-grow: 1; display: flex; flex-direction: column; }
        .st-top-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background-color: var(--st-panel-color); border-bottom: 1px solid var(--st-border-color); flex-shrink: 0; height: 50px;}
        .st-logo { font-family: 'GmarketSans', sans-serif; font-weight: bold; }
        .st-main-content { display: flex; flex-grow: 1; overflow: hidden; }
        .st-preview-area { flex-basis: 400px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        .st-editor-area { flex-grow: 1; border-left: 1px solid var(--st-border-color); overflow-y: auto; padding: 20px; }
        button { background-color: var(--st-accent-color); color: #fff; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; padding: 8px 12px; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        .st-preview-panel { width: 100%; max-width: 380px; aspect-ratio: 9 / 16; background-color: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .st-preview-header { position:relative; display: flex; align-items: center; justify-content: center; font-family: 'GmarketSans', sans-serif; color: white; font-weight: bold; flex-shrink: 0; height: 65px; padding: 0 15px; overflow: hidden; }
        .header-icon { position: absolute; left: 15px; display: flex; align-items: center; }
        .header-title { flex-grow: 1; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 0 45px; }
        .header-logo-container { position: absolute; right: 15px; display: flex; align-items: center; }
        .header-icon svg { width: 24px; height: 24px; }
        .header-logo { border-radius: 50%; object-fit: cover; background-color: #eee; }
        .st-preview-content { padding: 10px; color: black; flex-grow: 1; display: flex; flex-direction: column; background-color: white; overflow: hidden; position: relative; }
        .st-project-info { font-size: 13px; color: #555; margin: 0 0 16px 0; border-bottom: 1px solid #eee; padding-bottom: 16px; flex-shrink: 0; }
        .st-project-info .title { font-size: 22px; color: black; font-weight: bold; margin-bottom: 5px; }
        .st-script-display { flex-grow: 1; position: relative; }
        .interactive-target { position: absolute; width: 100%; text-align: center; cursor: move; }
        #st-preview-text-container-wrapper { z-index: 10; top: 50%; } /* 기본 위치 조정 */
        #st-preview-media-container-wrapper { z-index: 5; top: 8%; height: 40%;} /* 기본 위치 조정 */
        #st-preview-image, #st-preview-video { max-width: 100%; max-height: 100%; width: 100%; height: 100%; }
        #st-preview-video.fit-contain, #st-preview-image.fit-contain { object-fit: contain; }
        #st-preview-video.fit-cover, #st-preview-image.fit-cover { object-fit: cover; }
        #st-preview-video.fit-fill, #st-preview-image.fit-fill { object-fit: fill; }
        #st-preview-source-container-wrapper { position: absolute; bottom: 5px; right: 5px; width: auto; max-width: 95%; font-size: 10px; color: #888; text-align: right; }
        .interactive-target.interactive-active { outline: 2px dashed var(--st-interact-color); z-index: 100; }
        .resize-handle { position: absolute; width: 12px; height: 12px; background: white; border-radius: 50%; border: 2px solid var(--st-interact-color); z-index: 101; display: none; }
        .rotation-handle { position: absolute; bottom: -35px; left: 50%; transform: translateX(-50%); width: 24px; height: 24px; background-color: white; border-radius: 50%; border: 1px solid #ccc; cursor: grab; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 102; }
        .rotation-handle:active { cursor: grabbing; }
        .interactive-active .resize-handle, .interactive-active .rotation-handle { display: flex; }
        #st-preview-text, #st-preview-source-text { width: 100%; white-space: pre-wrap; }
        .st-timeline-controls { width: 100%; max-width: 380px; display: flex; align-items: center; gap: 10px; margin-top: 15px;}
        .st-play-all-btn { background: none; font-size: 24px; padding: 0;}
        #st-timeline-slider, .st-volume-slider, #st-setting-header-logo-size { flex-grow: 1; margin: 0; }
        .st-editor-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .st-card { background-color: var(--st-panel-color); border: 2px solid transparent; padding: 15px; margin-top: 15px; border-radius: 4px; cursor: pointer; position: relative; }
        .st-card.active { border-color: var(--st-accent-color); }
        .st-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .st-card-drag-handle { cursor: grab; }
        .st-card-number { font-weight: bold; font-size: 18px; }
        .st-editor-tip { font-size: 13px; color: var(--st-subtext-color); background-color: #252525; padding: 8px; border-radius: 4px; text-align: center; }
        .st-script-editor { width: 100%; min-height: 60px; background-color: #333; border: 1px solid var(--st-border-color); color: var(--st-text-color); border-radius: 4px; padding: 8px; outline: none; white-space: pre-wrap; }
        .st-script-editor .script-segment { cursor: grab; padding: 2px 0; }
        .st-script-editor .script-segment:active { cursor: grabbing; }
        .st-script-editor .script-segment.sortable-ghost { opacity: 0.4; background: #444; }
        .preview-text-segment { visibility: hidden; } /* 기본 숨김 처리 */
        .preview-text-segment.highlight { visibility: visible; } /* highlight 클래스로 보이기 */
        .st-card-footer { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        .st-card-footer .footer-row { display: flex; align-items: center; gap: 10px; font-size: 13px; flex-wrap: wrap; }
        .st-card-footer .st-duration-label { cursor: pointer; text-decoration: underline; }
        .st-card-footer .st-duration-input { width: 60px; padding: 2px 4px; }
        .st-card-footer .st-volume-slider { width: 70px; }
        .st-card-footer .media-fit-label { display: flex; align-items: center; gap: 5px; }
        input[type="file"] { display: none; }
        .st-action-btn { background: none; border:none; color: var(--st-subtext-color); text-decoration: underline; cursor: pointer; padding: 0; font-size: 13px; }
        .st-play-clip-btn { font-size: 18px; background: none; padding: 0 5px; cursor: pointer; border: none; color: var(--st-text-color); }
        .st-play-clip-btn:disabled { color: #555; cursor: not-allowed; }
        .st-card-loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; justify-content: center; align-items: center; z-index: 10; border-radius: 4px; font-weight: bold; }
        .st-accordion-header { padding: 12px 0; cursor: pointer; border-bottom: 1px solid var(--st-border-color); font-weight: bold; }
        .st-accordion-content { padding: 15px 0; display: none; }
        .st-accordion-item.active .st-accordion-content { display: block; }
        .st-control-group { margin-bottom: 15px; }
        .st-control-group h4 { margin-top: 0; margin-bottom: 10px; color: var(--st-subtext-color); border-bottom: 1px solid var(--st-border-color); padding-bottom: 8px; }
        input, select { width: 100%; padding: 8px; background-color: #1e1e1e; border: 1px solid var(--st-border-color); color: var(--st-text-color); }
        .st-flex-group { display: flex; gap: 10px; }
        .st-modal-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .st-modal-overlay.visible { display: flex; }
        .st-modal-dialog { background-color: var(--st-panel-color); padding: 24px; border-radius: 8px; width: 90%; max-width: 600px; border: 1px solid var(--st-border-color); }
        .st-modal-dialog .st-modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 24px; }
        #st-waveform-container { width: 100%; height: 128px; background-color: #1e1e1e; }
        #st-waveform-loading { text-align: center; padding: 40px; color: var(--st-subtext-color); }
        #st-export-progress-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; color: white; display: none; flex-direction: column; justify-content: center; align-items: center; font-size: 24px; }
        #st-export-progress-text { font-weight: bold; margin-bottom: 10px; }
        #st-export-progress-subtext { font-size: 16px; color: var(--st-subtext-color); }
        #st-export-progress-bar { width: 80%; max-width: 400px; height: 20px; background: #555; margin-top: 20px; border-radius: 10px; overflow: hidden; }
        #st-export-progress-bar-inner { width: 0%; height: 100%; background: var(--st-accent-color); transition: width 0.1s linear; }
        .st-app-footer { position: fixed; bottom: 0; left: 0; width: 100%; text-align: center; font-size: 12px; padding: 5px; background-color: var(--st-bg-color); color: var(--st-subtext-color); z-index: 1; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: #555; border-radius: 5px; outline: none; padding: 0; margin: auto 0; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--st-accent-color); border-radius: 50%; border: 2px solid #fff; margin-top: -5px; }
        input[type="range"]::-moz-range-track { width: 100%; height: 6px; background: #555; border-radius: 5px; border: none; }
        input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: var(--st-accent-color); border-radius: 50%; border: 2px solid #fff; }
        .animated { animation-fill-mode: forwards !important; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } .anim-fade-in { animation-name: fadeIn; }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } } .anim-fade-out { animation-name: fadeOut; }
        @keyframes zoomIn { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } } .anim-zoom-in { animation-name: zoomIn; }
        @keyframes zoomOut { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.5); } } .anim-zoom-out { animation-name: zoomOut; }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } .anim-slide-in-left { animation-name: slideInLeft; }
        @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } } .anim-slide-out-right { animation-name: slideOutRight; }
        @keyframes slideInUp { from { transform: translateY(100%); opacity: 0; } to { translateY(0); opacity: 1; } } .anim-slide-in-up { animation-name: slideInUp; }
        @keyframes slideOutDown { from { transform: translateY(0); opacity: 1; } to { translateY(100%); opacity: 0; } } .anim-slide-out-down { animation-name: slideOutDown; }
        #st-sequence-menu { position: fixed; z-index: 1001; background-color: var(--st-panel-color); border: 1px solid var(--st-border-color); border-radius: 5px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); list-style: none; padding: 5px 0; margin: 0; font-size: 14px; }
        #st-sequence-menu li { padding: 8px 15px; cursor: pointer; }
        #st-sequence-menu li:hover { background-color: var(--st-accent-color); color: white; }
        #st-sequence-menu hr { border: none; border-top: 1px solid var(--st-border-color); margin: 5px 0; }
    </style>
</head>
<body>
    <div class="st-panel st-sidebar" id="st-sidebar-container">
        <div id="st-global-settings-panel"></div>
        <div id="st-animation-settings-panel" style="display: none;"></div>
    </div>
    <div class="st-main-container">
        <div class="st-top-header">
            <div class="st-logo">SunsakTool</div>
            <button id="st-btn-export-video">🎬 영상 저장</button>
        </div>
        <div class="st-main-content">
            <div class="st-panel st-preview-area">
                <div class="st-preview-panel" id="st-preview-panel">
                     <div class="st-preview-header"><div class="header-icon"></div><div class="header-title"></div><div class="header-logo-container"><img class="header-logo"></div></div>
                     <div class="st-preview-content" id="st-preview-content">
                         <div class="st-project-info"><div class="title"></div><span></span></div>
                         <div class="st-script-display">
                            <div id="st-preview-media-container-wrapper" class="interactive-target" data-layout-key="media">
                                <img id="st-preview-image" style="display: none;">
                                <video id="st-preview-video" style="display: none;" muted playsinline></video>
                            </div>
                            <div id="st-preview-text-container-wrapper" class="interactive-target" data-layout-key="text"><div id="st-preview-text"></div></div>
                            <div id="st-preview-source-container-wrapper" class="interactive-target" data-layout-key="source" style="display: none;"><div id="st-preview-source-text"></div></div>
                         </div>
                     </div>
                </div>
                <div class="st-timeline-controls">
                    <button class="st-play-all-btn" id="st-btn-play-all">▶</button>
                    <input type="range" id="st-timeline-slider" value="0" step="0.1">
                </div>
            </div>
            <div class="st-panel st-editor-area">
                <div class="st-editor-header">
                    <h3>스크립트 & 타임라인</h3>
                    <div class="button-group">
                        <button id="st-btn-add-project" style="background-color: #555;">+ 새 프로젝트</button>
                        <button id="st-btn-add-gpts" style="background-color: #3e3e3e;">✨ AI 대본 생성</button>
                        <button id="st-btn-add-card">+ 수동 추가</button>
                    </div>
                </div>
                <div class="st-editor-tip">💡 Tip: 스크립트 줄을 드래그하여 순서를 바꾸거나, 텍스트 선택 후 순서 지정 메뉴를 사용하세요!</div>
                <div id="st-card-container"></div>
            </div>
        </div>
    </div>
    <div class="st-app-footer">Pro-Tip: 웹의 이미지를 복사(Ctrl+C)한 후, 카드를 클릭하고 붙여넣기(Ctrl+V) 해보세요!</div>
    
    <ul id="st-sequence-menu" style="display: none;"></ul>
    <div id="st-modal-gpts" class="st-modal-overlay"> <div class="st-modal-dialog"> <h2>AI 대본 붙여넣기</h2> <p>AI 툴(ChatGPT, Claude 등)에서 생성된 스크립트를 입력하세요. 빈 줄로 구분하여 여러 스크립트를 한번에 추가할 수 있습니다.</p> <textarea id="st-gpts-textarea" placeholder="여기에 AI 스크립트를 입력하세요..."></textarea> <div class="st-modal-actions"> <button id="st-btn-gpts-cancel" class="cancel">취소</button> <button id="st-btn-gpts-confirm">확인</button> </div> </div> </div>
    <div id="st-modal-bgm" class="st-modal-overlay"> <div class="st-modal-dialog"> <h2>BGM 구간 설정</h2> <p>오디오 파형 위에서 원하는 구간을 드래그하여 선택하세요.</p> <div id="st-waveform-container"> <div id="st-waveform-loading">BGM 로딩 중...</div> </div> <div class="st-waveform-controls"> <button id="st-btn-bgm-play-pause">재생/일시정지</button> <button id="st-btn-bgm-play-region">선택 구간 미리듣기</button> <span id="st-bgm-time-display">0.00s - 0.00s</span> </div> <div class="st-modal-actions"> <button id="st-btn-bgm-cancel" class="cancel">취소</button> <button id="st-btn-bgm-confirm">확인</button> </div> </div> </div>
    <div id="st-export-progress-overlay">
        <div id="st-export-progress-text">영상 생성 중...</div>
        <div id="st-export-progress-subtext"></div>
        <div id="st-export-progress-bar"><div id="st-export-progress-bar-inner"></div></div>
    </div>
    <canvas id="st-render-canvas" style="display: none;"></canvas>
    <audio id="st-tts-player" style="display:none;"></audio>
    <audio id="st-bgm-player" style="display:none;" loop></audio>
    <audio id="st-sfx-player" style="display:none;"></audio>
    <input type="file" id="st-sfx-file-upload" accept="audio/*" style="display: none;">
    <input type="file" id="st-bgm-file-upload" accept="audio/*" style="display: none;">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.4.0/wavesurfer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.4.0/plugin/wavesurfer.regions.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
    (function SunsakTool() {
        'use strict';

        // --- 1. 상수 (Constants) ---
        const C = {
            ANIMATION_LIST: [ { name: '없음', value: 'none' }, { name: '나타나기 (Fade In)', value: 'fade-in' }, { name: '사라지기 (Fade Out)', value: 'fade-out' }, { name: '확대하며 나타나기 (Zoom In)', value: 'zoom-in' }, { name: '축소하며 사라지기 (Zoom Out)', value: 'zoom-out' }, { name: '왼쪽에서 슬라이드 (Slide In Left)', value: 'slide-in-left' }, { name: '오른쪽으로 슬라이드 (Slide Out Right)', value: 'slide-out-right' }, { name: '위로 슬라이드 (Slide In Up)', value: 'slide-in-up' }, { name: '아래로 슬라이드 (Slide Out Down)', value: 'slide-out-down' }, ],
            FONT_LIST: [ { name: '프리텐다드 (본문용 추천)', value: 'Pretendard' }, { name: 'Noto Sans KR (기본 고딕)', value: "'Noto Sans KR', sans-serif" }, { name: 'G마켓 산스 (개성있는 제목)', value: 'GmarketSans' }, { name: 'IBM Plex Sans KR (모던한 고딕)', value: "'IBM Plex Sans KR', sans-serif" }, { name: 'Do Hyeon (레트로 제목)', value: "'Do Hyeon', sans-serif" }, { name: '나눔명조 (감성적인 본문)', value: "'Nanum Myeongjo', serif" }, { name: '고운 바탕 (부드러운 명조)', value: "'Gowun Batang', serif" }, { name: 'Black Han Sans (강력한 제목)', value: "'Black Han Sans', sans-serif" }, { name: '개구 (귀여운 손글씨)', value: "'Gaegu', cursive" }, { name: 'Hi Melody (아기자기 손글씨)', value: "'Hi Melody', cursive" }, { name: 'Noto Serif KR (정갈한 명조)', value: "'Noto Serif KR', serif" }, { name: '스포카 한 산스 네오 (깔끔한 본문)', value: "'Spoqa Han Sans Neo', sans-serif" }, { name: '독도 (거친 붓글씨)', value: "'Dokdo', cursive" }, ],
            BGM_LIST: [ { name: '선택 안함', url: '' }, { name: 'big-cafe', url: 'https://sunsaktool-final.netlify.app/big-cafe.mp3' }, { name: 'blue-jacket', url: 'https://sunsaktool-final.netlify.app/blue-jacket.mp3' }, { name: 'cute-puppy', url: 'https://sunsaktool-final.netlify.app/cute-puppy.mp3' }, { name: 'laughter-in-the-breeze', url: 'https://sunsaktool-final.netlify.app/laughter-in-the-breeze-_happy_.mp3' }, { name: 'murder-in-my-mind', url: 'https://sunsaktool-final.netlify.app/murder-in-my-mind.mp3' }, { name: 'smiley-composure', url: 'https://sunsaktool-final.netlify.app/smiley-composure.mp3' }, { name: 'spider', url: 'https://sunsaktool-final.netlify.app/spider.mp3' }, { name: 'white-color', url: 'https://sunsaktool-final.netlify.app/white-color.mp3' } ]
        };

        // --- 2. 상태 (State) ---
        const state = {
            sfxList: [{ name: "효과음 목록 로딩 중...", url: "" }],
            recentlyUsedSfx: [],
            sfxUploadTargetCardId: null,
            globalBGM: { url: null, volume: 0.3, startTime: 0, endTime: null },
            projectSettings: { 
                header: { text: '채널 이름', backgroundColor: '#e82c43', color: '#ffffff', fontFamily: 'GmarketSans', fontSize: 24, icon: 'none', logo: { url: null, size: 40 } }, 
                project: { title: '제목을 입력해주세요', author: 'ㅇㅇ', views: 0, titleColor: '#000000', metaColor: '#555555' },
                defaultStyle: { color: '#000000', fontFamily: "'Noto Sans KR', sans-serif", fontSize: '24', lineHeight: '1.5', letterSpacing: '0' }
            },
            scriptCards: [],
            isPlaying: false,
            ttsCache: new Map(),
            playbackCurrentIndex: 0,
            selectedCardId: null,
            activeInteractiveElement: null,
            playbackTimeoutId: null,
            currentSelectionContext: null, // 시퀀스 지정을 위한 컨텍스트
            currentPersistentMedia: null,
            wavesurfer: null,
            activeRegion: null,
            bgmEditorContext: { onConfirm: null, onCancel: null }
        };
        
        // --- 3. UI 요소 (DOM Elements) ---
        const UI = {
            cardContainer: document.getElementById('st-card-container'),
            playAllBtn: document.getElementById('st-btn-play-all'),
            timelineSlider: document.getElementById('st-timeline-slider'),
            ttsPlayer: document.getElementById('st-tts-player'),
            bgmPlayer: document.getElementById('st-bgm-player'),
            sfxPlayer: document.getElementById('st-sfx-player'),
            globalSettingsPanel: document.getElementById('st-global-settings-panel'),
            animationSettingsPanel: document.getElementById('st-animation-settings-panel'),
            addCardBtn: document.getElementById('st-btn-add-card'),
            addGptsBtn: document.getElementById('st-btn-add-gpts'),
            newProjectBtn: document.getElementById('st-btn-add-project'),
            gptsModal: document.getElementById('st-modal-gpts'),
            gptsCancelBtn: document.getElementById('st-btn-gpts-cancel'),
            gptsConfirmBtn: document.getElementById('st-btn-gpts-confirm'),
            gptsTextarea: document.getElementById('st-gpts-textarea'),
            sfxFileInput: document.getElementById('st-sfx-file-upload'),
            bgmFileInput: document.getElementById('st-bgm-file-upload'),
            sequenceMenu: document.getElementById('st-sequence-menu'),
            previewContent: document.getElementById('st-preview-content')
        };
        
        // --- 4. 헬퍼 함수 (Helpers) ---
        const helpers = {
            debounce: (callback, delay) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => callback(...args), delay);
                };
            },
            getAudioDuration: (url) => new Promise(resolve => {
                const audio = new Audio();
                audio.onloadedmetadata = () => resolve(audio.duration);
                audio.onerror = () => resolve(0.5); // Fallback
                audio.src = url;
            }),
            generateId: (prefix = 'id') => `${prefix}-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
            getGroupKey: (name) => {
                const keywords = ['물방울','클릭','등장','알림','타격','게임','스윕','넘어가는','넘기는','종이','카툰','폭발','팡파레','스우','깜짝','전자음'];
                for (const key of keywords) { if (name.includes(key)) return key; }
                return '기타';
            }
        };

        // --- 5. API 호출 ---
        async function fetchTTS(text, cardId) {
            text = text.trim();
            if (!text) return null;
            const cacheKey = text;
            if (state.ttsCache.has(cacheKey)) return state.ttsCache.get(cacheKey);
            render.showLoadingOnCard(cardId, true, '서버에 요청 중...');
            try {
                // 이 부분은 Netlify 서버리스 함수가 필요합니다.
                const response = await fetch('/.netlify/functions/create-tts', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ text: text }) 
                });
                if (!response.ok) {
                    const errorResult = await response.json();
                    throw new Error(`[${response.status}] ${errorResult.error || '서버 요청 실패'}`);
                }
                const result = await response.json();
                const audioUrl = result.audioUrl;
                const duration = await helpers.getAudioDuration(audioUrl);
                const ttsData = { audioUrl, duration };
                state.ttsCache.set(cacheKey, ttsData);
                return ttsData;
            } catch (error) {
                console.error('TTS 생성 오류:', error);
                alert(`음성 생성 중 오류가 발생했습니다: ${error.message}\n(백엔드 기능이 설정되지 않았을 수 있습니다.)`);
                return null;
            } finally {
                render.showLoadingOnCard(cardId, false);
            }
        }
        
        const debouncedTTSRequest = helpers.debounce(async (cardId) => {
            const cardData = state.scriptCards.find(c => c.id === cardId);
            if (!cardData) return;
            
            const allLines = cardData.text.split('\n').filter(line => line.trim());
            const sequencedLines = cardData.animationSequence || [];
            const remainingLines = allLines.filter(line => line && !sequencedLines.includes(line));
            const segmentsForTiming = [...sequencedLines, ...remainingLines];
            
            const textForTTS = segmentsForTiming.join(' ');
            
            if (!textForTTS) {
                cardData.ttsReady = false; cardData.duration = 0.5; cardData.ttsDuration = 0.5; cardData.segments = [];
                render.updateCardUI(cardId); handlers.updateTotalDuration();
                return;
            }
            
            const ttsData = await fetchTTS(textForTTS, cardId);
            if (ttsData && cardData) {
                cardData.ttsDuration = ttsData.duration;
                if (!cardData.isDurationManual) { cardData.duration = ttsData.duration; }
                cardData.audioUrl = ttsData.audioUrl;
                cardData.ttsReady = true;
                
                const totalChars = segmentsForTiming.reduce((sum, s) => sum + s.length, 0);
                let accumulatedTime = 0;
                cardData.segments = segmentsForTiming.map(segmentText => {
                    const segmentDuration = totalChars > 0 ? (segmentText.length / totalChars) * ttsData.duration : 0;
                    const segmentTiming = { text: segmentText, startTime: accumulatedTime, duration: segmentDuration };
                    accumulatedTime += segmentDuration;
                    return segmentTiming;
                });
                
                if (state.selectedCardId === cardId) {
                    render.updateCardUI(cardId);
                    render.updateMediaControls(cardId);
                }
                handlers.updateTotalDuration();
            }
        }, 800);

        // --- 6. 렌더링 함수 (Render Functions) ---
        const render = {
            showPanel(panelToShow) {
                UI.globalSettingsPanel.style.display = 'none';
                UI.animationSettingsPanel.style.display = 'none';
                if (panelToShow === 'global') {
                    UI.globalSettingsPanel.style.display = 'block';
                } else if (panelToShow === 'animation') {
                    UI.animationSettingsPanel.style.display = 'block';
                }
            },
            
            globalControls() {
                const fontOptions = C.FONT_LIST.map(font => `<option value="${font.value}" ${state.projectSettings.defaultStyle.fontFamily === font.value ? 'selected' : ''}>${font.name}</option>`).join('');
                const bgmOptions = C.BGM_LIST.map(bgm => `<option value="${bgm.url}">${bgm.name}</option>`).join('');
                UI.globalSettingsPanel.innerHTML = `
                    <div class="st-accordion-item active">
                        <div class="st-accordion-header">영상 설정</div>
                        <div class="st-accordion-content">
                            <div class="st-control-group"><h4>상단 헤더</h4><label>헤더 텍스트</label><input type="text" id="st-setting-header-text" value="${state.projectSettings.header.text}"><div class="st-flex-group" style="margin-top: 8px;"><div><label>배경 색상</label><input type="color" id="st-setting-header-bg" value="${state.projectSettings.header.backgroundColor}"></div><div><label>글자 색상</label><input type="color" id="st-setting-header-color" value="${state.projectSettings.header.color}"></div></div><div class="st-flex-group" style="margin-top: 8px;"><div><label>폰트</label><select id="st-setting-header-font">${fontOptions.replace(`value="${state.projectSettings.header.fontFamily}"`, `value="${state.projectSettings.header.fontFamily}" selected`)}</select></div><div><label>크기</label><input type="number" id="st-setting-header-size" value="${state.projectSettings.header.fontSize}"></div></div><div style="margin-top: 8px;"><label>왼쪽 아이콘</label><select id="st-setting-header-icon"><option value="none">없음</option><option value="back">뒤로가기</option><option value="menu">메뉴</option></select></div><div style="margin-top: 8px;"><label>오른쪽 로고</label><div class="st-flex-group"><button id="st-btn-header-logo" style="width: auto; flex-grow: 1;">로고 추가/변경</button><input type="file" id="st-header-logo-file" accept="image/*" style="display:none;"></div><label style="margin-top: 4px; display: block;">로고 크기: <span id="st-header-logo-size-label">${state.projectSettings.header.logo.size}</span>px</label><input type="range" id="st-setting-header-logo-size" min="20" max="60" value="${state.projectSettings.header.logo.size}"></div></div>
                            <div class="st-control-group"><h4>콘텐츠 정보</h4><label>프로젝트 제목</label><input type="text" id="st-setting-project-title" value="${state.projectSettings.project.title}"><div style="margin-top: 8px;"><label>작성자</label><input type="text" id="st-setting-project-author" value="${state.projectSettings.project.author}"></div><div style="margin-top: 8px;"><label>조회수</label><input type="number" id="st-setting-project-views" value="${state.projectSettings.project.views}"></div><div class="st-flex-group" style="margin-top: 8px;"><div><label>제목 색상</label><input type="color" id="st-setting-title-color" value="${state.projectSettings.project.titleColor}"></div><div><label>정보 색상</label><input type="color" id="st-setting-meta-color" value="${state.projectSettings.project.metaColor}"></div></div><hr style="border-color: var(--st-border-color); margin: 15px 0;"><label>기본 스크립트 스타일</label><div class="st-flex-group" style="margin-top: 8px;"><div><label>폰트</label><select id="st-setting-script-font">${fontOptions}</select></div><div><label>크기</label><input type="number" id="st-setting-script-size" value="${state.projectSettings.defaultStyle.fontSize}"></div></div><div style="margin-top: 8px;"><label>색상</label><input type="color" id="st-setting-script-color" value="${state.projectSettings.defaultStyle.color}"></div><div style="margin-top: 8px;"><label>줄 간격</label><input type="range" id="st-setting-line-height" min="1" max="2.5" step="0.1" value="${state.projectSettings.defaultStyle.lineHeight}"></div><div style="margin-top: 8px;"><label>자간</label><input type="range" id="st-setting-letter-spacing" min="-2" max="5" step="0.1" value="${state.projectSettings.defaultStyle.letterSpacing}"></div></div>
                            <div class="st-control-group"><h4>배경음악</h4><label>전체 BGM 선택</label><select id="st-setting-global-bgm">${bgmOptions}</select><button id="st-btn-upload-bgm" style="width:100%; margin-top: 8px; background-color: #3e3e3e;">내 BGM 업로드</button><div style="margin-top: 8px;"><label>BGM 볼륨</label><input type="range" id="st-setting-global-bgm-volume" min="0" max="1" step="0.01" value="${state.globalBGM.volume}"></div></div>
                        </div>
                    </div>`;
                UI.globalSettingsPanel.querySelector('.st-accordion-header').addEventListener('click', (e) => e.currentTarget.parentElement.classList.toggle('active'));
            },

            animationControls(element) {
                if (!state.selectedCardId || !element) return;
                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                const layoutKey = element.dataset.layoutKey;
                const anims = card.animations[layoutKey];
                const animOptions = C.ANIMATION_LIST.map(a => `<option value="${a.value}" ${anims.in.name === a.value ? 'selected' : ''}>${a.name}</option>`).join('');
                const animOptionsOut = C.ANIMATION_LIST.map(a => `<option value="${a.value}" ${anims.out.name === a.value ? 'selected' : ''}>${a.name}</option>`).join('');
                const elementType = layoutKey === 'text' ? '텍스트' : (layoutKey === 'media' ? '미디어' : '출처');
                
                UI.animationSettingsPanel.innerHTML = `<h3>${elementType} 애니메이션</h3>
                    <div class="st-control-group"><label>시작 애니메이션 (In)</label><select id="anim-in-type">${animOptions}</select><label>지속 시간 (초)</label><input type="number" id="anim-in-duration" min="0.1" max="5" step="0.1" value="${anims.in.duration}"></div>
                    <div class="st-control-group"><label>종료 애니메이션 (Out)</label><select id="anim-out-type">${animOptionsOut}</select><label>지속 시간 (초)</label><input type="number" id="anim-out-duration" min="0.1" max="5" step="0.1" value="${anims.out.duration}"></div>`;
                
                document.getElementById('anim-in-type').addEventListener('input', e => { anims.in.name = e.target.value; });
                document.getElementById('anim-in-duration').addEventListener('input', e => { anims.in.duration = parseFloat(e.target.value) || 0.3; });
                document.getElementById('anim-out-type').addEventListener('input', e => { anims.out.name = e.target.value; });
                document.getElementById('anim-out-duration').addEventListener('input', e => { anims.out.duration = parseFloat(e.target.value) || 0.3; });
                
                this.showPanel('animation');
            },
            
            sfxOptions: () => {
                const groups = {};
                state.sfxList.slice(1).filter(sfx => !state.recentlyUsedSfx.find(recent => recent.url === sfx.url)).forEach(sfx => {
                    const groupKey = helpers.getGroupKey(sfx.name);
                    if (!groups[groupKey]) groups[groupKey] = [];
                    groups[groupKey].push(sfx);
                });
                let optionsHtml = '<option value="">효과음 없음</option><option value="upload-my-own">--- 내 효과음 업로드 ---</option>';
                if (state.recentlyUsedSfx.length > 0) {
                    optionsHtml += '<optgroup label="최근 사용">';
                    state.recentlyUsedSfx.forEach(sfx => { optionsHtml += `<option value="${sfx.url}">${sfx.name}</option>`; });
                    optionsHtml += '</optgroup>';
                }
                Object.keys(groups).sort().forEach(groupName => {
                    optionsHtml += `<optgroup label="${groupName}">`;
                    groups[groupName].forEach(sfx => { optionsHtml += `<option value="${sfx.url}">${sfx.name}</option>`; });
                    optionsHtml += '</optgroup>';
                });
                return optionsHtml;
            },
            
            allSfxSelects: () => {
                const newOptions = render.sfxOptions();
                document.querySelectorAll('.st-card').forEach(cardEl => {
                    const id = cardEl.dataset.id;
                    const cardData = state.scriptCards.find(c => c.id === id);
                    const selectEl = cardEl.querySelector('.st-sfx-select');
                    if (selectEl && cardData) {
                        selectEl.innerHTML = newOptions;
                        selectEl.value = cardData.sfxUrl || '';
                    }
                });
            },

            cardElement: (cardData) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'st-card';
                cardEl.dataset.id = cardData.id;
                const sfxOptions = render.sfxOptions();
                cardEl.innerHTML = `
                    <div class="st-card-header st-card-drag-handle"><span class="st-card-number"></span><button class="st-btn-delete-card">🗑️</button></div>
                    <div class="st-script-editor" contenteditable="true" spellcheck="false"></div>
                    <div class="st-card-footer">
                        <div class="footer-row">
                            <button class="st-play-clip-btn" title="미리듣기" disabled>▶️</button>
                            <span class="st-duration-label" title="클릭하여 자동/수동 전환">길이(자동)</span>
                            <input type="number" class="st-duration-input" min="0.1" step="0.1" value="${cardData.duration}" title="길이(초)" style="display: none;">
                            <label class="st-action-btn" for="${cardData.id}-file">미디어 추가</label>
                            <input type="file" id="${cardData.id}-file" accept="image/*,video/*">
                        </div>
                        <div class="footer-row media-controls" style="display: none;">
                            <span>미디어 표시:</span><select class="media-timing-select"></select>
                            <span>지속 시간:</span><select class="media-persist-select"></select>
                        </div>
                        <div class="footer-row media-controls" style="display: none;">
                           <span>비디오 맞춤:</span>
                           <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="cover">꽉 채우기</label>
                           <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="contain" checked>안에 맞추기</label>
                           <label class="media-fit-label"><input type="radio" name="media-fit-${cardData.id}" value="fill">늘리기</label>
                        </div>
                        <div class="footer-row">
                            <span>TTS 소리</span><input type="range" class="st-volume-slider tts-volume" min="0" max="1" step="0.05" value="${cardData.ttsVolume}">
                            <span style="margin-left:10px;">효과음 소리</span><input type="range" class="st-volume-slider sfx-volume" min="0" max="1" step="0.05" value="${cardData.sfxVolume}">
                        </div>
                        <div class="footer-row"><select class="st-sfx-select" style="flex-grow: 1;">${sfxOptions}</select></div>
                    </div>`;
                cardEl.querySelector('.st-sfx-select').value = cardData.sfxUrl || '';
                return cardEl;
            },
            
            segmentsInEditor: (editorEl, text) => {
                editorEl.innerHTML = '';
                const lines = text.split('\n');
                if (lines.length === 1 && lines[0] === '') {
                    editorEl.innerHTML = '<p class="script-segment"><br></p>';
                } else {
                    lines.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'script-segment';
                        p.textContent = line;
                        editorEl.appendChild(p);
                    });
                }
            },
            
            updateCardUI: (cardId) => {
                const cardData = state.scriptCards.find(c => c.id === cardId);
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardData || !cardEl) return;

                cardEl.querySelector('.st-play-clip-btn').disabled = !cardData.ttsReady;
                cardEl.querySelector('.tts-volume').value = cardData.ttsVolume;
                cardEl.querySelector('.sfx-volume').value = cardData.sfxVolume;
                
                const durationLabel = cardEl.querySelector('.st-duration-label');
                const durationInput = cardEl.querySelector('.st-duration-input');
                durationInput.value = (cardData.duration || 0).toFixed(2);
                durationInput.style.display = cardData.isDurationManual ? 'inline-block' : 'none';
                durationLabel.textContent = `길이(${cardData.isDurationManual ? '수동' : '자동'})`;

                render.updateMediaControls(cardId);
            },
            
            updateMediaControls(cardId) {
                const cardData = state.scriptCards.find(c => c.id === cardId);
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardData || !cardEl) return;
                
                const mediaControls = cardEl.querySelectorAll('.media-controls');
                
                if (cardData.media.url) {
                    mediaControls.forEach(el => el.style.display = 'flex');

                    const timingSelect = cardEl.querySelector('.media-timing-select');
                    timingSelect.innerHTML = `<option value="1">스크립트 시작 시</option>`;
                    if (cardData.segments.length > 1) {
                        cardData.segments.forEach((seg, i) => {
                            timingSelect.innerHTML += `<option value="${i + 2}">"${seg.text.substring(0, 10)}..." 이후</option>`;
                        });
                    }
                    timingSelect.value = cardData.media.showOnSegment;

                    const persistSelect = cardEl.querySelector('.media-persist-select');
                    const currentIndex = state.scriptCards.findIndex(c => c.id === cardId);
                    persistSelect.innerHTML = `<option value="">이 클립에서만</option>`;
                    if (currentIndex < state.scriptCards.length - 1) {
                         state.scriptCards.slice(currentIndex).forEach((c, i) => {
                             if(i > 0) persistSelect.innerHTML += `<option value="${c.id}">카드 ${currentIndex + i + 1}까지</option>`;
                         });
                    }
                    persistSelect.value = cardData.media.persistUntilCardId || '';

                    cardEl.querySelector(`input[name="media-fit-${cardId}"][value="${cardData.media.fit}"]`).checked = true;

                } else {
                    mediaControls.forEach(el => el.style.display = 'none');
                }
            },
            
            updateCardNumbers: () => {
                const allCardElements = UI.cardContainer.querySelectorAll('.st-card');
                state.scriptCards.forEach((cardData, index) => {
                    const cardEl = Array.from(allCardElements).find(el => el.dataset.id === cardData.id);
                    if (cardEl) {
                        cardEl.querySelector('.st-card-number').textContent = index + 1;
                    }
                });
                state.scriptCards.forEach(card => render.updateMediaControls(card.id));
            },
            
            showLoadingOnCard: (cardId, show, message) => {
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (!cardEl) return;
                let overlay = cardEl.querySelector('.st-card-loading');
                if (show) {
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.className = 'st-card-loading';
                        cardEl.appendChild(overlay);
                    }
                    overlay.textContent = message;
                } else {
                    if (overlay) overlay.remove();
                }
            },

            applyTransform: (el, layout) => {
                if (el && layout) {
                    el.style.transform = `translate(${layout.x}px, ${layout.y}px) scale(${layout.scale}) rotate(${layout.angle}deg)`;
                }
            },
            
            updatePreviewDisplay(forPlayback = false) {
                const headerEl = document.querySelector('.st-preview-header');
                const headerIconEl = headerEl.querySelector('.header-icon');
                const headerTitleEl = headerEl.querySelector('.header-title');
                const headerLogoEl = headerEl.querySelector('.header-logo');
                headerTitleEl.textContent = state.projectSettings.header.text;
                headerEl.style.backgroundColor = state.projectSettings.header.backgroundColor;
                headerEl.style.color = state.projectSettings.header.color;
                headerEl.style.fontFamily = state.projectSettings.header.fontFamily;
                headerTitleEl.style.fontSize = state.projectSettings.header.fontSize + 'px';
                const iconSVG = {
                    back: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${state.projectSettings.header.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`,
                    menu: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${state.projectSettings.header.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`
                };
                headerIconEl.innerHTML = iconSVG[state.projectSettings.header.icon] || '';
                if (state.projectSettings.header.logo.url) {
                    headerLogoEl.src = state.projectSettings.header.logo.url;
                    headerLogoEl.style.width = state.projectSettings.header.logo.size + 'px';
                    headerLogoEl.style.height = state.projectSettings.header.logo.size + 'px';
                    headerLogoEl.style.display = 'block';
                } else {
                    headerLogoEl.style.display = 'none';
                }
                const titleEl = document.querySelector('.st-project-info .title');
                titleEl.textContent = state.projectSettings.project.title;
                titleEl.style.color = state.projectSettings.project.titleColor;
                const metaEl = document.querySelector('.st-project-info span');
                metaEl.textContent = `${state.projectSettings.project.author || ''} | 조회수 ${Number(state.projectSettings.project.views || 0).toLocaleString()}`;
                metaEl.style.color = state.projectSettings.project.metaColor;

                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                const textWrapper = document.getElementById('st-preview-text-container-wrapper');
                const previewText = document.getElementById('st-preview-text');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                const previewImage = document.getElementById('st-preview-image');
                const previewVideo = document.getElementById('st-preview-video');
                
                if (!card) {
                    textWrapper.style.display = 'none'; mediaWrapper.style.display = 'none';
                    return;
                }
                
                [textWrapper, mediaWrapper].forEach(el => {
                    const key = el.dataset.layoutKey;
                    el.className = `interactive-target ${el.classList.contains('interactive-active') ? 'interactive-active' : ''}`;
                    el.style.animation = '';
                    el.style.opacity = '1';
                    if (card.layout[key]) render.applyTransform(el, card.layout[key]);
                });
                
                textWrapper.style.display = 'block';
                Object.assign(previewText.style, card.style);
                
                previewText.innerHTML = '';
                // 일반 미리보기에서는 모든 텍스트를 한 번에 보여줌
                card.text.split('\n').forEach(line => {
                    const p = document.createElement('p');
                    p.className = 'preview-text-segment highlight'; // 항상 보이도록 highlight
                    p.textContent = line || ' '; 
                    p.style.margin = 0;
                    previewText.appendChild(p);
                });
                
                render.applyTransform(textWrapper, card.layout.text);
                
                if (card.media.url) {
                    mediaWrapper.style.display = 'flex';
                    const targetEl = card.media.type === 'video' ? previewVideo : previewImage;
                    const otherEl = card.media.type === 'video' ? previewImage : previewVideo;
                    targetEl.style.display = 'block'; otherEl.style.display = 'none';
                    if (targetEl.src !== card.media.url) targetEl.src = card.media.url;
                    targetEl.className = `fit-${card.media.fit}`;
                    render.applyTransform(mediaWrapper, card.layout.media);
                } else {
                    mediaWrapper.style.display = 'none';
                }
            },
        };
        
        // --- 7. 재생 관련 함수 (Playback) ---
        const playback = {
            togglePlay: () => {
                state.isPlaying ? playback.stop() : playback.start();
            },
            
            start: () => {
                interaction.deactivateAllInteractive();
                const unready = state.scriptCards.some(c => !c.ttsReady && c.text.trim());
                if (unready) return alert('아직 음성 생성이 완료되지 않은 스크립트가 있습니다.');
                if (state.scriptCards.length === 0) return;
                
                state.isPlaying = true; UI.playAllBtn.textContent = '❚❚';
                playback.playBGM();
                playback.playCardByIndex(0);
            },
            
            stop: () => {
                state.isPlaying = false;
                clearTimeout(state.playbackTimeoutId);
                UI.playAllBtn.textContent = '▶';
                UI.ttsPlayer.pause(); UI.bgmPlayer.pause(); UI.sfxPlayer.pause();
                document.getElementById('st-preview-video').pause();
                state.currentPersistentMedia = null;
                render.updatePreviewDisplay();
            },

            playBGM: (bgmData = state.globalBGM) => {
                if (bgmData && bgmData.url) {
                    if (UI.bgmPlayer.src !== bgmData.url) UI.bgmPlayer.src = bgmData.url;
                    UI.bgmPlayer.volume = state.globalBGM.volume;
                    UI.bgmPlayer.currentTime = bgmData.startTime || 0;
                    UI.bgmPlayer.play().catch(e => console.error("BGM Playback Error:", e));
                } else {
                    UI.bgmPlayer.pause();
                }
            },

            playCardByIndex: (index) => {
                if (index >= state.scriptCards.length || !state.isPlaying) {
                    playback.stop();
                    return;
                }
                
                state.playbackCurrentIndex = index;
                const card = state.scriptCards[index];
                handlers.selectCard(card.id, true);
                render.updatePreviewDisplay(true); // 재생용 렌더링 모드
                
                const previewTextEl = document.getElementById('st-preview-text');
                const previewVideo = document.getElementById('st-preview-video');
                const previewImage = document.getElementById('st-preview-image');
                const mediaWrapper = document.getElementById('st-preview-media-container-wrapper');
                
                // --- 텍스트 재생 로직 (누적 표시) ---
                previewTextEl.innerHTML = ''; // 일단 비움
                const segmentElements = [];
                // 모든 세그먼트 p 태그를 미리 만들고 숨김
                if (card.segments && card.segments.length > 0) {
                    card.segments.forEach(segment => {
                        const p = document.createElement('p');
                        p.className = 'preview-text-segment'; // highlight 없음
                        p.textContent = segment.text || ' ';
                        p.style.margin = 0;
                        previewTextEl.appendChild(p);
                        segmentElements.push(p);
                    });
                     // 시간차를 두고 highlight 클래스 추가
                    card.segments.forEach((segment, segIndex) => {
                        setTimeout(() => {
                            if (state.isPlaying && state.playbackCurrentIndex === index && segmentElements[segIndex]) {
                                segmentElements[segIndex].classList.add('highlight');
                            }
                        }, segment.startTime * 1000);
                    });
                } else { // 세그먼트 없는 경우
                     const p = document.createElement('p');
                     p.className = 'preview-text-segment highlight';
                     p.textContent = card.text || ' ';
                     p.style.margin = 0;
                     previewTextEl.appendChild(p);
                }

                // --- 미디어 재생 로직 (지속성 포함) ---
                if (card.media.url && card.media.persistUntilCardId) {
                    state.currentPersistentMedia = { ...card.media, startCardId: card.id };
                }
                
                let activeMedia = state.currentPersistentMedia || (card.media.url ? card.media : null);
                mediaWrapper.style.visibility = activeMedia ? 'visible' : 'hidden';

                if(activeMedia) {
                    const targetEl = activeMedia.type === 'video' ? previewVideo : previewImage;
                    if (targetEl.src !== activeMedia.url) targetEl.src = activeMedia.url;
                    targetEl.className = `fit-${activeMedia.fit}`;

                    if (activeMedia.type === 'video') {
                       if (state.currentPersistentMedia && previewVideo.paused) {
                            previewVideo.currentTime = 0;
                            previewVideo.play().catch(()=>{});
                       } else if (!state.currentPersistentMedia) {
                           previewVideo.currentTime = 0;
                           previewVideo.play().catch(()=>{});
                       }
                    }
                }
                
                // 오디오 재생
                if (card.audioUrl) { UI.ttsPlayer.volume = card.ttsVolume; UI.ttsPlayer.src = card.audioUrl; UI.ttsPlayer.play(); }
                if (card.sfxUrl) { UI.sfxPlayer.volume = card.sfxVolume; UI.sfxPlayer.src = card.sfxUrl; UI.sfxPlayer.play(); }
                
                // 지속성 미디어 종료
                if (state.currentPersistentMedia && state.currentPersistentMedia.persistUntilCardId === card.id) {
                    state.currentPersistentMedia = null;
                }
                
                state.playbackTimeoutId = setTimeout(() => {
                    if (state.isPlaying) playback.playCardByIndex(index + 1);
                }, card.duration * 1000);
            }
        };

        // --- 8. 이벤트 핸들러 (Event Handlers) ---
        const handlers = {
            updateProjectSettings() {
                state.projectSettings.header.text = document.getElementById('st-setting-header-text').value;
                state.projectSettings.header.backgroundColor = document.getElementById('st-setting-header-bg').value;
                state.projectSettings.header.color = document.getElementById('st-setting-header-color').value;
                state.projectSettings.header.fontFamily = document.getElementById('st-setting-header-font').value;
                state.projectSettings.header.fontSize = document.getElementById('st-setting-header-size').value;
                state.projectSettings.header.icon = document.getElementById('st-setting-header-icon').value;
                state.projectSettings.project.title = document.getElementById('st-setting-project-title').value;
                state.projectSettings.project.author = document.getElementById('st-setting-project-author').value;
                state.projectSettings.project.views = document.getElementById('st-setting-project-views').value;
                state.projectSettings.project.titleColor = document.getElementById('st-setting-title-color').value;
                state.projectSettings.project.metaColor = document.getElementById('st-setting-meta-color').value;
                state.projectSettings.defaultStyle.color = document.getElementById('st-setting-script-color').value;
                state.projectSettings.defaultStyle.fontFamily = document.getElementById('st-setting-script-font').value;
                state.projectSettings.defaultStyle.fontSize = document.getElementById('st-setting-script-size').value;
                state.projectSettings.defaultStyle.lineHeight = document.getElementById('st-setting-line-height').value;
                state.projectSettings.defaultStyle.letterSpacing = document.getElementById('st-setting-letter-spacing').value;
                handlers.applyScriptStylesToSelectedCard();
                render.updatePreviewDisplay();
            },
            
            updateScriptStyleControls() {
                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                if (!card) return;
                document.getElementById('st-setting-script-color').value = card.style?.color || '#000000';
                document.getElementById('st-setting-script-font').value = card.style?.fontFamily || "'Noto Sans KR', sans-serif";
                document.getElementById('st-setting-script-size').value = (card.style?.fontSize || '24px').replace('px','');
                document.getElementById('st-setting-line-height').value = card.style?.lineHeight || '1.5';
                document.getElementById('st-setting-letter-spacing').value = (card.style?.letterSpacing || '0px').replace('px','');
            },

            applyScriptStylesToSelectedCard() {
                const card = state.scriptCards.find(c => c.id === state.selectedCardId);
                if (!card) return;
                card.style = {
                    color: document.getElementById('st-setting-script-color').value,
                    fontFamily: document.getElementById('st-setting-script-font').value,
                    fontSize: document.getElementById('st-setting-script-size').value + 'px',
                    lineHeight: document.getElementById('st-setting-line-height').value,
                    letterSpacing: document.getElementById('st-setting-letter-spacing').value + 'px'
                };
                render.updatePreviewDisplay();
            },

            addScriptCard(text = '') {
                const cardId = helpers.generateId('card');
                const cardData = {
                    id: cardId, text, segments: [], animationSequence: [], duration: 0.5, ttsDuration: 0.5, isDurationManual: false,
                    media: { url: null, type: null, fit: 'contain', showOnSegment: 1, persistUntilCardId: null },
                    style: { ...state.projectSettings.defaultStyle, fontSize: state.projectSettings.defaultStyle.fontSize + 'px', letterSpacing: state.projectSettings.defaultStyle.letterSpacing + 'px' },
                    audioUrl: null, ttsReady: false, ttsVolume: 0.8, sfxUrl: null, sfxVolume: 0.8,
                    // 기본 레이아웃 위치 조정 (미디어 위, 텍스트 아래)
                    layout: { text: { x: 0, y: 150, scale: 1, angle: 0 }, media: { x: 0, y: -80, scale: 1, angle: 0 } },
                    animations: { text: { in: { name: 'none', duration: 0.3 }, out: { name: 'none', duration: 0.3 } }, media: { in: { name: 'none', duration: 0.3 }, out: { name: 'none', duration: 0.3 } } }
                };
                state.scriptCards.push(cardData);
                const cardEl = render.cardElement(cardData);
                UI.cardContainer.appendChild(cardEl);
                handlers.bindCardEvents(cardId);
                
                const editor = cardEl.querySelector('.st-script-editor');
                render.segmentsInEditor(editor, cardData.text);
                debouncedTTSRequest(cardId);
                
                if (!state.selectedCardId) {
                    handlers.selectCard(cardId);
                }
                
                render.updateCardNumbers();
                render.updateCardUI(cardId);
            },
            
            bindCardEvents(cardId) {
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                const cardData = state.scriptCards.find(c => c.id === cardId);
                const editor = cardEl.querySelector('.st-script-editor');
                
                editor.addEventListener('input', () => {
                    cardData.text = Array.from(editor.children).map(child => child.textContent).join('\n');
                    render.updatePreviewDisplay();
                    debouncedTTSRequest(cardId);
                });
                
                new Sortable(editor, { animation: 150, ghostClass: 'sortable-ghost', onEnd: () => { 
                    cardData.text = Array.from(editor.children).map(child => child.textContent).join('\n');
                    render.updatePreviewDisplay();
                    debouncedTTSRequest(cardId);
                }});

                cardEl.querySelector(`#${cardId}-file`).addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        cardData.media.url = URL.createObjectURL(file);
                        cardData.media.type = file.type.startsWith('video/') ? 'video' : 'image';
                        render.updateMediaControls(cardId);
                        if (state.selectedCardId === cardId) render.updatePreviewDisplay();
                    }
                });
                
                cardEl.querySelector('.media-timing-select').addEventListener('change', e => cardData.media.showOnSegment = parseInt(e.target.value, 10));
                cardEl.querySelector('.media-persist-select').addEventListener('change', e => cardData.media.persistUntilCardId = e.target.value || null);
                cardEl.querySelectorAll(`input[name="media-fit-${cardId}"]`).forEach(radio => {
                    radio.addEventListener('change', e => {
                        cardData.media.fit = e.target.value;
                        if(state.selectedCardId === cardId) render.updatePreviewDisplay();
                    });
                });
                cardEl.querySelector('.st-play-clip-btn').addEventListener('click', (e) => {
                    e.stopPropagation(); playback.stop();
                    if (cardData.ttsReady && cardData.audioUrl) { UI.ttsPlayer.volume = cardData.ttsVolume; UI.ttsPlayer.src = cardData.audioUrl; UI.ttsPlayer.play(); }
                    if (cardData.sfxUrl) { UI.sfxPlayer.src = cardData.sfxUrl; UI.sfxPlayer.volume = cardData.sfxVolume; UI.sfxPlayer.play(); }
                });
                cardEl.querySelector('.st-sfx-select').addEventListener('change', (e) => {
                    const url = e.target.value;
                    if (url === 'upload-my-own') {
                        state.sfxUploadTargetCardId = cardId;
                        UI.sfxFileInput.value = null; UI.sfxFileInput.click();
                        e.target.value = cardData.sfxUrl || '';
                        return;
                    }
                    cardData.sfxUrl = url || null;
                    if (url) {
                        UI.sfxPlayer.src = url; UI.sfxPlayer.volume = cardData.sfxVolume; UI.sfxPlayer.play();
                        const sfxItem = state.sfxList.find(item => item.url === url);
                        if (sfxItem) {
                            state.recentlyUsedSfx = [sfxItem, ...state.recentlyUsedSfx.filter(item => item.url !== url)].slice(0, 5);
                            render.allSfxSelects();
                        }
                    }
                });
                cardEl.querySelector('.tts-volume').addEventListener('input', e => { cardData.ttsVolume = parseFloat(e.target.value); });
                cardEl.querySelector('.sfx-volume').addEventListener('input', e => { cardData.sfxVolume = parseFloat(e.target.value); });
                cardEl.querySelector('.st-duration-label').addEventListener('click', () => {
                    cardData.isDurationManual = !cardData.isDurationManual;
                    if (!cardData.isDurationManual) { cardData.duration = cardData.ttsDuration; }
                    render.updateCardUI(cardId);
                    handlers.updateTotalDuration();
                });
                cardEl.querySelector('.st-duration-input').addEventListener('input', (e) => {
                    if (cardData.isDurationManual) { cardData.duration = parseFloat(e.target.value) || 0.5; handlers.updateTotalDuration(); }
                });
                cardEl.querySelector('.st-btn-delete-card').addEventListener('click', (e) => { e.stopPropagation(); handlers.deleteCard(cardId); });
                cardEl.addEventListener('click', () => handlers.selectCard(cardId));
            },

            deleteCard(cardId) {
                const cardIndex = state.scriptCards.findIndex(c => c.id === cardId);
                if (cardIndex === -1) return;
                
                state.scriptCards.splice(cardIndex, 1);
                document.querySelector(`.st-card[data-id="${cardId}"]`).remove();
                
                if (state.selectedCardId === cardId) {
                    state.selectedCardId = null;
                    if (state.scriptCards.length > 0) {
                        const nextIndex = Math.max(0, cardIndex - 1);
                        if (state.scriptCards[nextIndex]) handlers.selectCard(state.scriptCards[nextIndex].id);
                    } else {
                        render.updatePreviewDisplay();
                    }
                }
                handlers.updateTotalDuration();
                render.updateCardNumbers();
                interaction.deactivateAllInteractive();
            },
            
            updateTotalDuration() {
                const total = state.scriptCards.reduce((sum, card) => sum + (card.duration || 0.5), 0);
                if (UI.timelineSlider) UI.timelineSlider.max = total;
            },
            
            selectCard(cardId, fromPlayback = false) {
                if (state.isPlaying && !fromPlayback) playback.stop();
                state.selectedCardId = cardId;
                interaction.deactivateAllInteractive();
                
                document.querySelectorAll('.st-card').forEach(c => c.classList.remove('active'));
                const cardEl = document.querySelector(`.st-card[data-id="${cardId}"]`);
                if (cardEl) {
                    cardEl.classList.add('active');
                    if (!fromPlayback) cardEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    handlers.updateScriptStyleControls();
                }
                render.updatePreviewDisplay();
            },
        };
        
        // --- 9. 인터랙션 (Interaction) & 시퀀스(Sequence) ---
        const interaction = {
            deactivateAllInteractive() {
                document.querySelectorAll('.interactive-target.interactive-active').forEach(el => {
                    el.classList.remove('interactive-active');
                    el.querySelectorAll('.resize-handle, .rotation-handle').forEach(h => h.remove());
                });
                state.activeInteractiveElement = null;
                render.showPanel('global');
            },

            activateInteractive(target) {
                if (state.activeInteractiveElement === target) return;
                interaction.deactivateAllInteractive();
                state.activeInteractiveElement = target;
                target.classList.add('interactive-active');
                
                ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle`;
                    handle.style.top = pos.includes('top') ? '-6px' : ''; handle.style.bottom = pos.includes('bottom') ? '-6px' : '';
                    handle.style.left = pos.includes('left') ? '-6px' : ''; handle.style.right = pos.includes('right') ? '-6px' : '';
                    handle.style.cursor = pos === 'top-left' || pos === 'bottom-right' ? 'nwse-resize' : 'nesw-resize';
                    target.appendChild(handle);
                });
                
                const rotHandle = document.createElement('div'); rotHandle.className = 'rotation-handle';
                rotHandle.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.7594 20.0001C11.5894 20.5301 8.20942 19.5601 5.86942 17.2201C2.59942 13.9501 2.59942 8.55006 5.86942 5.28006C9.13942 2.01006 14.5394 2.01006 17.8094 5.28006C19.7994 7.27006 20.6594 9.87006 20.4794 12.4401" stroke="#333" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/><path d="M15.4297 12.4401L20.4797 12.4401L18.4297 10.3901" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                target.appendChild(rotHandle);
                
                render.animationControls(target);
            },

            sequence: {
                showMenu: (x, y) => {
                    const { cardId } = state.currentSelectionContext;
                    const cardData = state.scriptCards.find(c => c.id === cardId);
                    if(!cardData) return;
                    const sequence = cardData.animationSequence || [];
                    let menuItems = '';
                    for(let i=0; i <= sequence.length; i++) {
                        menuItems += `<li data-action="set" data-index="${i}">${i + 1}번째로 재생</li>`;
                    }
                    menuItems += '<hr><li data-action="clear">순서 초기화</li>';
                    UI.sequenceMenu.innerHTML = menuItems;
                    UI.sequenceMenu.style.left = `${x + 10}px`;
                    UI.sequenceMenu.style.top = `${y}px`;
                    UI.sequenceMenu.style.display = 'block';
                },
                hideMenu: () => {
                    UI.sequenceMenu.style.display = 'none';
                    state.currentSelectionContext = null;
                },
                handleMenuClick: (e) => {
                    if (e.target.tagName !== 'LI' || !state.currentSelectionContext) return;
                    const { cardId, text } = state.currentSelectionContext;
                    const cardData = state.scriptCards.find(c => c.id === cardId);
                    if (!cardData) return;
                    
                    const action = e.target.dataset.action;
                    if (action === 'set') {
                        const index = parseInt(e.target.dataset.index, 10);
                        cardData.animationSequence = cardData.animationSequence.filter(seqText => seqText !== text);
                        cardData.animationSequence.splice(index, 0, text);
                    } else if (action === 'clear') {
                        cardData.animationSequence = [];
                    }
                    debouncedTTSRequest(cardId);
                    interaction.sequence.hideMenu();
                },
                onSelectionChange: () => {
                    const selection = window.getSelection();
                    if (!selection || selection.isCollapsed) {
                        interaction.sequence.hideMenu();
                        return;
                    }
                    const editor = selection.anchorNode?.parentElement?.closest('.st-script-editor');
                    if(editor) {
                        const range = selection.getRangeAt(0);
                        const segmentEl = range.startContainer.parentElement.closest('.script-segment');
                        if (!segmentEl || !segmentEl.textContent.trim()) {
                            interaction.sequence.hideMenu();
                            return;
                        }
                        const cardEl = editor.closest('.st-card');
                        state.currentSelectionContext = { cardId: cardEl.dataset.id, text: selection.toString().trim() };
                        if(state.currentSelectionContext.text) {
                            const rect = range.getBoundingClientRect();
                            interaction.sequence.showMenu(rect.right, rect.top);
                        }
                    } else {
                        interaction.sequence.hideMenu();
                    }
                }
            },

            initialize() {
                interact('.interactive-target').on('tap', (event) => {
                    interaction.activateInteractive(event.currentTarget);
                    event.preventDefault();
                });
                
                const interactionListeners = {
                    start(event) { document.body.classList.add('interaction-active'); if(event.target.closest('.interactive-target')) event.target.closest('.interactive-target').classList.add('interacting'); },
                    move(event) {
                        const card = state.scriptCards.find(c => c.id === state.selectedCardId); if (!card) return;
                        const layoutKey = event.target.dataset.layoutKey; const layout = card.layout[layoutKey];
                        layout.x += event.dx; layout.y += event.dy;
                        render.applyTransform(event.target, layout);
                    },
                    end(event) { document.body.classList.remove('interaction-active'); document.querySelectorAll('.interacting').forEach(el => el.classList.remove('interacting')); }
                };

                interact('.interactive-target').draggable({ listeners: interactionListeners });

                interact('.interactive-target').resizable({
                    edges: { top: true, left: true, bottom: true, right: true },
                    listeners: {
                        start: interactionListeners.start,
                        move(event) {
                            const card = state.scriptCards.find(c => c.id === state.selectedCardId); if (!card) return;
                            const layoutKey = event.target.dataset.layoutKey; const layout = card.layout[layoutKey];
                            layout.x += event.deltaRect.left; layout.y += event.deltaRect.top;
                            // scale is now managed by css object-fit, so we don't change scale on resize
                            Object.assign(event.target.style, { width: `${event.rect.width}px`, height: `${event.rect.height}px` });
                            // render.applyTransform(event.target, layout); // a transform would be redundant
                        },
                        end: interactionListeners.end
                    },
                    modifiers: [ interact.modifiers.aspectRatio({ ratio: 'preserve' }) ],
                    inertia: true
                });

                UI.previewContent.addEventListener('click', (e) => {
                    if (!e.target.closest('.interactive-target')) {
                        interaction.deactivateAllInteractive();
                    }
                });

                // 시퀀스 메뉴 이벤트
                document.addEventListener('selectionchange', helpers.debounce(interaction.sequence.onSelectionChange, 200));
                document.addEventListener('mousedown', (e) => {
                    if (!UI.sequenceMenu.contains(e.target) && !e.target.closest('.st-script-editor')) {
                        interaction.sequence.hideMenu();
                    }
                });
                UI.sequenceMenu.addEventListener('click', interaction.sequence.handleMenuClick);
            }
        };

        // --- 10. 초기화 (Initialization) ---
        async function initialize() {
            try {
                const response = await fetch('https://sunsaktool-final.netlify.app/sfx-list.json');
                if (!response.ok) throw new Error('Network response was not ok');
                state.sfxList = await response.json();
            } catch (e) {
                console.error("효과음 목록(sfx-list.json)을 불러오는 데 실패했습니다.", e);
                state.sfxList = [{ name: "효과음 목록 로딩 실패", url: "" }];
            }

            render.globalControls();
            
            // 전역 이벤트 리스너 바인딩
            UI.addCardBtn.addEventListener('click', () => handlers.addScriptCard(''));
            UI.newProjectBtn.addEventListener('click', () => { if(confirm('정말로 새 프로젝트를 시작하시겠습니까? 모든 작업 내용이 사라집니다.')) { location.reload(); } });
            UI.playAllBtn.addEventListener('click', playback.togglePlay);
            UI.globalSettingsPanel.addEventListener('input', (e) => { if (e.target.id.startsWith('st-setting-')) handlers.updateProjectSettings(); });
            document.getElementById('st-btn-upload-bgm').addEventListener('click', () => UI.bgmFileInput.click());
            document.getElementById('st-btn-header-logo').addEventListener('click', () => document.getElementById('st-header-logo-file').click());
            
            interaction.initialize();
            
            new Sortable(UI.cardContainer, { 
                animation: 150, handle: '.st-card-drag-handle',
                onEnd: function(evt) {
                    const { oldIndex, newIndex } = evt;
                    const [movedItem] = state.scriptCards.splice(oldIndex, 1);
                    state.scriptCards.splice(newIndex, 0, movedItem);
                    render.updateCardNumbers();
                }
            });

            handlers.addScriptCard('순삭툴에 오신 것을 환영합니다!\n텍스트를 선택해서 재생 순서를 정해보세요.');
        }

        document.addEventListener('DOMContentLoaded', initialize);

    })(); // 즉시 실행 함수 종료
    </script>
</body>
</html>
